{"title":"ES6总结（中）","uid":"788d899c6b4422522bb9706082cc38c8","slug":"ES6总结（中）","date":"2023-02-15T03:05:41.000Z","updated":"2023-02-15T03:16:01.434Z","comments":true,"path":"api/articles/ES6总结（中）.json","keywords":null,"cover":"https://img-blog.csdnimg.cn/20200401220041648.gif","content":"<p>本次的<strong>ES6语法的汇总</strong>总共分为<strong>上、中、下</strong>三篇，本篇文章为中篇。</p>\n<p>汇总上篇文章请戳这里–<a href=\"https://link.zhihu.com/?target=https://juejin.im/post/5d28422be51d457756536829\">谈谈ES6语法（汇总上篇）</a></p>\n<p>好了，我们直奔中篇的内容～</p>\n<h3 id=\"数组扩展\"><a href=\"#数组扩展\" class=\"headerlink\" title=\"数组扩展\"></a>数组扩展</h3><h3 id=\"数组扩展运算符\"><a href=\"#数组扩展运算符\" class=\"headerlink\" title=\"数组扩展运算符\"></a>数组扩展运算符</h3><p>数组扩展运算符（spread）是三个点（<code>...</code>）。它好比<strong>rest参数的逆运算</strong>，将一个数组转为用空格分隔的参数序列。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">console.log(...[1, 2, 3]); &#x2F;&#x2F; 1 2 3\nconsole.log(1, ...[2, 3, 4], 5); &#x2F;&#x2F; 1 2 3 4 5<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>⚠️rest参数是运用在函数参数上的，将函数参数转换为数组的形式，如下：  </p></blockquote>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">function fn(...values) &#123;\n  console.log(values); &#x2F;&#x2F; [&#39;jia&#39;, &#39;ming&#39;]\n&#125;\nfn(&#39;jia&#39;, &#39;ming&#39;);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>下面我们结合数组扩展运算符和rest参数来实现一个类似<code>call</code>的方法call2操作：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Function.prototype.call2 &#x3D; function(context, ...args)&#123; &#x2F;&#x2F; 这里使用到rest参数\n    context &#x3D; context || window; &#x2F;&#x2F; 因为传递过来的context有可能是null\n    context.fn &#x3D; this; &#x2F;&#x2F; 让fn的上下文为context\n    const result &#x3D; context.fn(...args); &#x2F;&#x2F; 这里使用了数组扩展运算符\n    delete context.fn;\n    return result; &#x2F;&#x2F; 因为有可能this函数会有返回值return\n&#125;\nvar job &#x3D; &#39;outter teacher&#39;;\nvar obj &#x3D; &#123;\n    job: &#39;inner teacher&#39;\n&#125;;\nfunction showJob() &#123;\n    console.log(this.job);\n&#125;\nshowJob(); &#x2F;&#x2F; outter teacher\nshowJob.call2(obj); &#x2F;&#x2F; inner teacher<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>复习一下，我们把<code>var job = &#39;outter teacher&#39;</code>改为<code>let job = &#39;outter teacher&#39;</code>后，<code>showJob()</code>会输出什么？</p>\n<p>答案是<code>undefined</code>。在前一篇中也提到过，ES6语法声明的变量是不会挂载在全局对象上的～</p>\n<h3 id=\"Array-from\"><a href=\"#Array-from\" class=\"headerlink\" title=\"Array.from()\"></a>Array.from()</h3><p><code>Array.from</code>方法用于将<code>两类对象</code>转为<strong>真正的数组</strong>：类似数组的对象（array-like object）和可遍历（iterable）的对象（对象包括ES6新增的数据结构Set和Map）。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 类数组转化成数组\nlet arrayLike &#x3D; &#123;\n    &#39;0&#39;: &#39;a&#39;,\n    &#39;1&#39;: &#39;b&#39;,\n    &#39;2&#39;: &#39;c&#39;,\n    length: 3\n&#125;\n\n&#x2F;&#x2F; ES5的写法\nvar arr1 &#x3D; [].slice.call(arrayLike); &#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]\n\n&#x2F;&#x2F; ES6的写法\nlet arr2 &#x3D; Array.from(arrayLike); &#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"Array-of\"><a href=\"#Array-of\" class=\"headerlink\" title=\"Array.of()\"></a>Array.of()</h3><p><code>Array.of()</code>方法用于将一组值，转换为数组。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">let arr &#x3D; Array.of(2, 3, &#39;reng&#39;);\nconsole.log(arr); &#x2F;&#x2F; [2, 3, &#39;reng&#39;]\nconsole.log(arr.pop()); &#x2F;&#x2F; reng<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p><code>Array.of</code>基本上可以弥补<code>Array()或new Array()</code>带来的因为参数个数导致的不同行为。<code>Array.of</code>基本上可以替代它们两个了。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Array.of(); &#x2F;&#x2F; []\nArray.of(&#39;reng&#39;); &#x2F;&#x2F; [&#39;reng&#39;]\nArray.of(2, &#39;reng&#39;); &#x2F;&#x2F; [2, &#39;reng&#39;]<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>数组中还有其它有用的方法：</p>\n<ul>\n<li>copyWithin(target, start &#x3D; 0, end &#x3D; this.length): 拷贝指定数组的范围值</li>\n<li>find(fn): 用于查找第一个符合条件的数组成员，没有返回undefined</li>\n<li>findIndex(fn): 用于查找第一个符合条件的数组成员的位置，没有返回-1</li>\n<li>entries(): 对键值对的遍历</li>\n<li>keys(): 对键的遍历</li>\n<li>values(): 对值的遍历</li>\n<li>includes(el): 返回一个布尔值，表示某个数组是否包含给定的值，与字符串的<code>include(el)</code>方法相似</li>\n<li>flat(num): 将嵌套的数组拉平，num是遍历的深度</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">[1, [2, [3]]].flat(Infinity);\n&#x2F;&#x2F; [1, 2, 3]<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>有这么一个需求：<code>将数组[[2, 8], [2], [[4, 6], 7, 6]]转成一维且元素不重复的数组。</code></p>\n<p>我们的实现方案如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">let arr &#x3D; [[2, 8], [2], [[4, 6], 7, 6]];\nconsole.log([...new Set(arr.flat(Infinity))]); &#x2F;&#x2F; [2, 8, 4, 6, 7]<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h3 id=\"对象扩展\"><a href=\"#对象扩展\" class=\"headerlink\" title=\"对象扩展\"></a>对象扩展</h3><h3 id=\"属性名表达式\"><a href=\"#属性名表达式\" class=\"headerlink\" title=\"属性名表达式\"></a>属性名表达式</h3><p>ES6允许字面量定义对象时，把表达式放在方括号内：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">let lastWord &#x3D; &#39;last word&#39;;\n\nconst a &#x3D; &#123;\n  &#39;first word&#39;: &#39;hello&#39;,\n  [lastWord]: &#39;world&#39;,\n  [&#39;end&#39;+&#39;symbol&#39;]: &#39;!&#39; \n&#125;;\n\na[&#39;first word&#39;] &#x2F;&#x2F; &#39;hello&#39;\na[lastWord] &#x2F;&#x2F; &#39;world&#39;\na[&#39;last word&#39;] &#x2F;&#x2F; &#39;world&#39;\na[&#39;endsymbol&#39;] &#x2F;&#x2F; &#39;!&#39;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"对象的扩展运算符\"><a href=\"#对象的扩展运算符\" class=\"headerlink\" title=\"对象的扩展运算符\"></a>对象的扩展运算符</h3><p>上面整理数组扩展内容的时候，提到了数组的扩展运算符。<code>ES2018</code>将这个运算符引入了对象～</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">let z &#x3D; &#123; a: 3, b: 4 &#125;;\nlet n &#x3D; &#123; ...z &#125;; &#x2F;&#x2F; 关键点\nn &#x2F;&#x2F; &#123; a: 3, b: 4 &#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"对象中某些新增的方法\"><a href=\"#对象中某些新增的方法\" class=\"headerlink\" title=\"对象中某些新增的方法\"></a>对象中某些新增的方法</h3><ul>\n<li>Object.is(arg1, arg2): 比较两个值是否严格相等，与<code>===</code>行为基本一致</li>\n<li>Object.assign(target, source1, …): 用于对象的合并，将源对象(source)的所有可枚举属性，复制到目标对象(target)。属于浅拷贝</li>\n<li>Object.keys(obj): 返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名</li>\n<li>Object.values(obj): 方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。</li>\n<li>Object.entries(obj): 方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const obj &#x3D; &#123; foo: &#39;bar&#39;, baz: 42 &#125;;\nObject.entries(obj)\n&#x2F;&#x2F; [ [&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, 42] ]<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"Set和Map数据结构\"><a href=\"#Set和Map数据结构\" class=\"headerlink\" title=\"Set和Map数据结构\"></a>Set和Map数据结构</h3><h3 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h3><p><code>Set</code>翻译出来就是集合，有元素唯一性的特点。</p>\n<p>在数组去重的场景上很有用处：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 去除数组的重复成员\n[...new Set(array)]\n&#x2F;&#x2F; 如\nconsole.log([...new Set([2, 2, 3, 2])]); &#x2F;&#x2F; [2, 3]<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>需要留意的<strong>Set属性和方法</strong>有以下：</p>\n<ul>\n<li>size: 返回实例成员的总数</li>\n<li>add(value): 添加某个值，返回Set结构本身</li>\n<li>delete(value): 删除某个值，返回一个布尔值，表示删除是否成功。</li>\n<li>has(value): 返回一个布尔值，表示该值是否为Set的成员</li>\n<li>clear(): 清除所有成员，没有返回值。</li>\n<li>key():返回键名的遍历器。</li>\n<li>values(): 返回键值的遍历器。</li>\n<li>entries(): 返回键值对的遍历器。</li>\n<li>forEach(): 使用回调函数遍历每个成员</li>\n</ul>\n<h3 id=\"WeakSet\"><a href=\"#WeakSet\" class=\"headerlink\" title=\"WeakSet\"></a>WeakSet</h3><p><code>WeakSet</code>结构与<code>Set</code>类似，也是有不重复元素的集合。但是它和Set有两个区别：</p>\n<ol>\n<li><p><code>WeakSet</code>对象中只能存放对象引用, 不能存放值, 而<code>Set</code>对象都可以.  </p>\n</li>\n<li><p><code>WeakSet中</code>对象中存储的对象值都是被弱引用的, 如果没有其他的变量或属性引用这个对象值, 则这个对象值会被当成垃圾回收掉. 正因为这样, WeakSet 对象是无法被枚举的, 没有办法拿到它包含的所有元素。</p>\n</li>\n</ol>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">var ws &#x3D; new WeakSet();\nvar obj &#x3D; &#123;&#125;;\nvar foo &#x3D; &#123;&#125;;\n\nws.add(window);\nws.add(obj);\n\nws.has(window); &#x2F;&#x2F; true\nws.has(foo);    &#x2F;&#x2F; false, 对象 foo 并没有被添加进 ws 中 \n\nws.delete(window); &#x2F;&#x2F; 从集合中删除 window 对象\nws.has(window);    &#x2F;&#x2F; false, window 对象已经被删除了\n\nws.clear(); &#x2F;&#x2F; 清空整个 WeakSet 对象<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>WeakSet 没有size属性，没有办法遍历它的成员</strong>。</p>\n<h3 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h3><p><code>Map</code>对象保持键值对。任何值（对象或者原始值）都可以作为一个键或一个值。</p>\n<p><strong>Object和Map的比较：</strong></p>\n<ul>\n<li>一个<code>Object</code>的键只能是字符串或者<code>Symbols</code>，但一个<code>Map</code>的键可以是任意值，包括函数、对象、基本类型。</li>\n<li><code>Map</code>中的键值是有序的，而添加到对象中的键则不是。因此，当对它进行遍历时，<code>Map</code>对象是按插入的顺序返回键值。</li>\n<li><code>Map</code>在涉及频繁增删键值对的场景下会有些性能优势`。</li>\n<li>…</li>\n</ul>\n<p>如果你需要“键值对”的数据结构，<code>Map</code>比<code>Object</code>更合适。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const set &#x3D; new Set([ &#x2F;&#x2F; 数组转换为map\n  [&#39;foo&#39;, 1],\n  [&#39;bar&#39;, 2]\n]);\nconst m1 &#x3D; new Map(set);\nm1.get(&#39;foo&#39;) &#x2F;&#x2F; 1\n\nconst m2 &#x3D; new Map([[&#39;baz&#39;, 3]]);\nconst m3 &#x3D; new Map(m2);\nm3.get(&#39;baz&#39;) &#x2F;&#x2F; 3<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>Map拥有的属性和方法和Set相似，多出了些：</p>\n<ul>\n<li>set(key, value)：set方法设置键名key对应的键值为value，然后返回整个 Map 结构。如果key已经有值，则键值会被更新，否则就新生成该键。</li>\n<li>get(key)：get方法读取key对应的键值，如果找不到key，返回undefined</li>\n</ul>\n<h3 id=\"WeakMap\"><a href=\"#WeakMap\" class=\"headerlink\" title=\"WeakMap\"></a>WeakMap</h3><p><code>WeakMap</code>结构与<code>Map</code>结构类似，也是用于生成键值对的集合。但是有两点区别：</p>\n<ul>\n<li><code>WeakMap</code>只接受对象作为键名（null除外），不接受其他类型的值作为键名。</li>\n<li><code>WeakMap</code>的键名所指向的对象，不计入垃圾回收机制。和<code>WeakSet</code>相似啦。</li>\n</ul>\n<p>属性方法啥的跟<code>Map</code>差不多，就是没有了<code>size</code>和<code>forEach</code>，因为其是不可枚举的。</p>\n<h3 id=\"Promise对象\"><a href=\"#Promise对象\" class=\"headerlink\" title=\"Promise对象\"></a>Promise对象</h3><p><code>Promise</code>是异步编程的一种解决方案，比传统的解决方案“回调函数和事件”更合理和更强大。</p>\n<p><code>Promise</code>对象有以下两个特点：</p>\n<ol>\n<li><p>对象的状态不受外界影响。<code>Promise</code>对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。  </p>\n</li>\n<li><p>一旦状态改变，就不会再变，任何时候都可以得到这个结果。<code>Promise</code>对象的状态改变，只有两种情况：从<code>pending</code>变成<code>fulfilled（fulfilled也称resolved）</code>和从<code>pending</code>变成<code>rejected</code>。</p>\n</li>\n</ol>\n<h3 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">const promise &#x3D; new Promise(function(resolve, reject) &#123;\n    &#x2F;&#x2F; ...some code\n\n    if(&#x2F;* 异步操作成功 *&#x2F;) &#123;\n        resolve(value);\n    &#125; else &#123;\n        reject(error);\n    &#125;\n&#125;)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>参数<code>resolve</code>和<code>reject</code>是两个函数，由JavaScript引擎提供，不用自己部署。</p>\n<p><code>Promise</code>实例生成之后，可以使用<code>then</code>方法分别指定<code>resolved</code>状态和<code>rejected</code>状态的回调函数。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">promise.then(function(value) &#123;\n    &#x2F;&#x2F; success\n&#125;, function(error) &#123;\n    &#x2F;&#x2F; failure\n&#125;);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>我们来粘贴个简单例子：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">function timeout(ms) &#123;\n    return new Promise((resolve, reject) &#x3D;&gt; &#123;\n        setTimeout(resolve, ms, &#39;done&#39;);\n    &#125;);\n&#125;\n\ntimeout(100).then((value) &#x3D;&gt; &#123;\n    console.log(value); &#x2F;&#x2F; 100ms后输出&#39;done&#39;\n&#125;);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>嗯～我们顺道来复习下<code>setTimeout</code>的第三个参数。哦 ，不，是第三个，第四个…</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">var timeoutID &#x3D; scope.setTimeout(function[, delay, param1, param2, ...]);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<ul>\n<li><code>function</code> 是你想要在到期时间（<code>delay</code>毫秒）之后执行的函数。</li>\n<li><code>delay</code> 是可选语法，表示延迟的毫秒数。</li>\n<li><code>param1, ..., paramN</code> 是可选的附加参数，一旦定时器到期，它们会作为参数传递给<code>function</code></li>\n</ul>\n<p>那么，到这里你理解了上面的例子为什么在<code>100ms</code>后输出<code>done</code>了嘛</p>\n<p>详细的<code>setTimeout</code>信息，请戳<a href=\"https://link.zhihu.com/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setTimeout\">MDN的setTimeout</a>。</p>\n<p>简单的例子看完了，看下我们在工作中使用得比较多的请求接口的例子：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const getJSON &#x3D; function(url) &#123;\n    const promise &#x3D; new Promise(function(resolve, reject)&#123;\n        const handler &#x3D; function() &#123;\n            if(this.readyState !&#x3D;&#x3D; 4) &#123;\n                return;\n            &#125;\n            if(this.status &#x3D;&#x3D;&#x3D; 200) &#123;\n                resolve(this.response); &#x2F;&#x2F; this.response作为参数传给then中的json\n            &#125; else &#123;\n                reject(new Error(this.statusText));\n            &#125;\n        &#125;;\n        const client &#x3D; new XMLHttpRequest();\n        client.open(&#39;GET&#39;, url);\n        client.onreadystatechange &#x3D; handler;\n        client.responseType &#x3D; &#39;json&#39;;\n        client.setRequestHeader(&#39;Accept&#39;, &#39;application.json&#39;);\n        client.send();\n    &#125;);\n    return promise;\n&#125;;\ngetJSON(&#39;&#x2F;post.json&#39;).then(function(json) &#123;\n    console.log(&#39;Contents: &#39;+ json);\n&#125;, function(error) &#123;\n    console.log(&#39;error happen &#39;, error);\n&#125;);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"catch方法\"><a href=\"#catch方法\" class=\"headerlink\" title=\"catch方法\"></a>catch方法</h3><p><code>Promise.prototype.catch</code>方法是<code>.then(null, rejection)</code>或<code>.then(undefined, rejection)</code>的别名，用于指定发生错误时的回调函数。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">p.then((val) &#x3D;&gt; console.log(&#39;fulfilled:&#39;, val))\n    .catch((err) &#x3D;&gt; console.log(&#39;rejected&#39;, err)); &#x2F;&#x2F; promise中任何一个抛出错误，都会被最后一个catch捕获\n\n&#x2F;&#x2F; 等同于\np.then((val) &#x3D;&gt; console.log(&#39;fulfilled:&#39;, val))\n    .then(null, (err) &#x3D;&gt; console.log(&#39;rejected:&#39;, err));<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"finally方法\"><a href=\"#finally方法\" class=\"headerlink\" title=\"finally方法\"></a>finally方法</h3><p><code>Promise.prototype.finally()</code>方法（其不接受任何参数）用于指定不管<code>Promise</code>对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。</p>\n<p>语法：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">promise\n    .then(result &#x3D;&gt; &#123;···&#125;)\n    .catch(error &#x3D;&gt; &#123;···&#125;)\n    .finally(() &#x3D;&gt; &#123;···&#125;);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"Promise-all\"><a href=\"#Promise-all\" class=\"headerlink\" title=\"Promise.all\"></a>Promise.all</h3><p>构造函数方法<code>Promise.all</code>方法用于将多个<code>Promise</code>实例，包装成一个新的<code>Promise</code>实例。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const p &#x3D; Promise.all([p1, p2, p3]);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>上面代码中，<code>Promise.all</code>方法接受<strong>一个数组</strong>作为参数，<code>p1, p2, p3</code>都是<code>Promise</code>实例。如果不是会调用<code>Promise.resolve</code>方法，具体看<a href=\"https://link.zhihu.com/?target=http://es6.ruanyifeng.com/%23docs/promise\">文档</a>。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 生成一个Promise对象的数组\nconst promises &#x3D; [2, 3, 5, 7, 11, 13].map(function (id) &#123;\n    return getJSON(&#39;&#x2F;post&#x2F;&#39; + id + &quot;.json&quot;);\n&#125;);\n\nPromise.all(promises).then(function (posts) &#123;\n    &#x2F;&#x2F; ...\n&#125;).catch(function(reason)&#123;\n    &#x2F;&#x2F; ...\n&#125;);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>上面代码中，<code>promises</code>是包含 6 个 <code>Promise</code> 实例的数组，只有这<strong>6</strong>个实例的状态都变成<code>fulfilled</code>，或者其中有一个变为<code>rejected</code>，才会调用<code>Promise.all</code>方法后面的回调函数。</p>\n<p>⚠️注意，如果作为参数的<code>Promise</code>实例，自己定义了<code>catch</code>方法，那么它一旦被<code>rejected</code>，并不会触发<code>Promise.all()</code>的<code>catch</code>方法。所以使用<code>Promise.all()</code>别手痒在每个实例promise内添加错误捕获。</p>\n<h3 id=\"一道练手题\"><a href=\"#一道练手题\" class=\"headerlink\" title=\"一道练手题\"></a>一道练手题</h3><p>需求：使用promise改写下面的代码，使得输出的期望结果是每隔一秒输出<code>0, 1, 2, 3, 4, 5</code>，其中<code>i &lt; 5</code>条件不能变</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">for(var i &#x3D; 0 ; i &lt; 5; i++)&#123;\n    setTimeout(function()&#123;\n        console.log(i);\n    &#125;,1000)\n&#125;\nconsole.log(i);<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>我们直接上使用promise改写的代码吧～</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">const tasks &#x3D; []; &#x2F;&#x2F; 存放promise对象\nfor(let i &#x3D; 0; i &lt; 5; i++)&#123;\n    tasks.push(new Promise((resolve) &#x3D;&gt; &#123;\n        setTimeout(() &#x3D;&gt; &#123;\n            console.log(i);\n            resolve();\n        &#125;, 1000 * i);\n    &#125;));\n&#125;\nPromise.all(tasks).then(() &#x3D;&gt; &#123;\n    setTimeout(() &#x3D;&gt; &#123;\n        console.log(tasks.length);\n    &#125;, 1000);\n&#125;);\n&#x2F;&#x2F; 每隔一秒输出 0, 1, 2, 3, 4, 5<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"参考和后话\"><a href=\"#参考和后话\" class=\"headerlink\" title=\"参考和后话\"></a>参考和后话</h3><ul>\n<li><a href=\"https://link.zhihu.com/?target=http://es6.ruanyifeng.com/\">阮一峰的ES6教程</a></li>\n<li><a href=\"https://link.zhihu.com/?target=https://codepen.io/\">codepen 代码验证</a></li>\n</ul>\n<p>本次的<strong>ES6语法的汇总</strong>总共分为<strong>上、中、下</strong>三篇，本篇文章为中篇。</p>\n<ul>\n<li><a href=\"https://link.zhihu.com/?target=https://juejin.im/post/5d28422be51d457756536829\">谈谈ES6语法（汇总上篇）</a></li>\n</ul>\n<p>文章首发在github上–<a href=\"https://link.zhihu.com/?target=https://github.com/reng99/blogs/issues/37\">谈谈ES6语法（汇总中篇）</a>。更多的内容，请戳<a href=\"https://link.zhihu.com/?target=https://github.com/reng99/blogs\">我的博客</a>进行了解，能留个star就更好了</p>\n","feature":true,"text":"本次的ES6语法的汇总总共分为上、中、下三篇，本篇文章为中篇。 汇总上篇文章请戳这里–谈谈ES6语法（汇总上篇） 好了，我们直奔中篇的内容～ 数组扩展数组扩展运算符数组扩展运算符（spread）是三个点（...）。它好比rest参数的逆运算，将一个数组转为用空格分隔的参数序列。 ...","link":"","photos":[],"count_time":{"symbolsCount":"10k","symbolsTime":"9 mins."},"categories":[{"name":"前端","slug":"前端","count":3,"path":"api/categories/前端.json"},{"name":"Javascript","slug":"前端/Javascript","count":3,"path":"api/categories/前端/Javascript.json"}],"tags":[{"name":"ES6","slug":"ES6","count":3,"path":"api/tags/ES6.json"},{"name":"Javascript","slug":"Javascript","count":3,"path":"api/tags/Javascript.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84%E6%89%A9%E5%B1%95\"><span class=\"toc-text\">数组扩展</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B0%E7%BB%84%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6\"><span class=\"toc-text\">数组扩展运算符</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Array-from\"><span class=\"toc-text\">Array.from()</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Array-of\"><span class=\"toc-text\">Array.of()</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E8%B1%A1%E6%89%A9%E5%B1%95\"><span class=\"toc-text\">对象扩展</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B1%9E%E6%80%A7%E5%90%8D%E8%A1%A8%E8%BE%BE%E5%BC%8F\"><span class=\"toc-text\">属性名表达式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6\"><span class=\"toc-text\">对象的扩展运算符</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E8%B1%A1%E4%B8%AD%E6%9F%90%E4%BA%9B%E6%96%B0%E5%A2%9E%E7%9A%84%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">对象中某些新增的方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Set%E5%92%8CMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">Set和Map数据结构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Set\"><span class=\"toc-text\">Set</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#WeakSet\"><span class=\"toc-text\">WeakSet</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Map\"><span class=\"toc-text\">Map</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#WeakMap\"><span class=\"toc-text\">WeakMap</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Promise%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">Promise对象</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%94%A8%E6%B3%95\"><span class=\"toc-text\">用法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#catch%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">catch方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#finally%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">finally方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Promise-all\"><span class=\"toc-text\">Promise.all</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80%E9%81%93%E7%BB%83%E6%89%8B%E9%A2%98\"><span class=\"toc-text\">一道练手题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%82%E8%80%83%E5%92%8C%E5%90%8E%E8%AF%9D\"><span class=\"toc-text\">参考和后话</span></a></li></ol>","author":{"name":"Abner","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Abner223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"mapped":true,"prev_post":{"title":"ES6总结（上）","uid":"a5237b480be45e0469c9d124561aa992","slug":"ES6总结（上）","date":"2023-02-15T03:05:41.000Z","updated":"2023-02-15T03:09:51.476Z","comments":true,"path":"api/articles/ES6总结（上）.json","keywords":null,"cover":"https://source.unsplash.com/ukzHlkoz1IE/1200x628","text":" 作者：JowayYoung仓库：Github、CodePen博客：官网、掘金、思否、知乎公众号：IQ前端特别声明：原创不易，未经授权不得转载或抄袭，如需转载可联系笔者授权 前言第三次阅读阮一峰老师的《ES6标准入门》了，以前阅读时不细心，很多地方都是一目十行。最近这次阅读都是逐...","link":"","photos":[],"count_time":{"symbolsCount":"32k","symbolsTime":"29 mins."},"categories":[{"name":"前端","slug":"前端","count":3,"path":"api/categories/前端.json"},{"name":"Javascript","slug":"前端/Javascript","count":3,"path":"api/categories/前端/Javascript.json"}],"tags":[{"name":"ES6","slug":"ES6","count":3,"path":"api/tags/ES6.json"},{"name":"Javascript","slug":"Javascript","count":3,"path":"api/tags/Javascript.json"}],"author":{"name":"Abner","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Abner223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"feature":true},"next_post":{"title":"ES6总结（下）","uid":"94921aa9a74f7374b2a5c0d12ec8143a","slug":"ES6总结（下）","date":"2023-02-15T03:05:41.000Z","updated":"2023-02-15T03:18:12.836Z","comments":true,"path":"api/articles/ES6总结（下）.json","keywords":null,"cover":"https://source.unsplash.com/N4wqYiRZrLI/1200x628","text":"本次的ES6语法的汇总总共分为上、中、下三篇，本篇文章为下篇。 往期系列文章： 谈谈ES6语法（汇总上篇） 谈谈ES6语法（汇总中篇） 客套话不多说了，直奔下篇的内容～ async函数ES2017标准引入了async函数，使得异步操作更加方便。async函数是Generator函...","link":"","photos":[],"count_time":{"symbolsCount":"8.1k","symbolsTime":"7 mins."},"categories":[{"name":"前端","slug":"前端","count":3,"path":"api/categories/前端.json"},{"name":"Javascript","slug":"前端/Javascript","count":3,"path":"api/categories/前端/Javascript.json"}],"tags":[{"name":"ES6","slug":"ES6","count":3,"path":"api/tags/ES6.json"},{"name":"Javascript","slug":"Javascript","count":3,"path":"api/tags/Javascript.json"}],"author":{"name":"Abner","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Abner223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"feature":true}}