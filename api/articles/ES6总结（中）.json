{"title":"ES6总结（中）","uid":"788d899c6b4422522bb9706082cc38c8","slug":"ES6总结（中）","date":"2023-02-15T03:05:41.000Z","updated":"2023-02-15T03:10:10.842Z","comments":true,"path":"api/articles/ES6总结（中）.json","keywords":null,"cover":"https://img-blog.csdnimg.cn/20200401220041648.gif","content":"<p>本次的ES6语法的汇总总共分为上、中、下三篇，本篇文章为中篇。</p>\n<p>汇总上篇文章请戳这里–谈谈ES6语法（汇总上篇）</p>\n<p>好了，我们直奔中篇的内容～</p>\n<p>数组扩展</p>\n<p>数组扩展运算符</p>\n<p>数组扩展运算符（spread）是三个点（…）。它好比rest参数的逆运算，将一个数组转为用空格分隔的参数序列。</p>\n<p>console.log(…[1, 2, 3]); &#x2F;&#x2F; 1 2 3<br>console.log(1, …[2, 3, 4], 5); &#x2F;&#x2F; 1 2 3 4 5<br>⚠️rest参数是运用在函数参数上的，将函数参数转换为数组的形式，如下：<br>function fn(…values) {<br>  console.log(values); &#x2F;&#x2F; [‘jia’, ‘ming’]<br>}<br>fn(‘jia’, ‘ming’);<br>下面我们结合数组扩展运算符和rest参数来实现一个类似call的方法call2操作：</p>\n<p>Function.prototype.call2 &#x3D; function(context, …args){ &#x2F;&#x2F; 这里使用到rest参数<br>    context &#x3D; context || window; &#x2F;&#x2F; 因为传递过来的context有可能是null<br>    context.fn &#x3D; this; &#x2F;&#x2F; 让fn的上下文为context<br>    const result &#x3D; context.fn(…args); &#x2F;&#x2F; 这里使用了数组扩展运算符<br>    delete context.fn;<br>    return result; &#x2F;&#x2F; 因为有可能this函数会有返回值return<br>}<br>var job &#x3D; ‘outter teacher’;<br>var obj &#x3D; {<br>    job: ‘inner teacher’<br>};<br>function showJob() {<br>    console.log(this.job);<br>}<br>showJob(); &#x2F;&#x2F; outter teacher<br>showJob.call2(obj); &#x2F;&#x2F; inner teacher<br>复习一下，我们把var job &#x3D; ‘outter teacher’改为let job &#x3D; ‘outter teacher’后，showJob()会输出什么？</p>\n<p>答案是undefined。在前一篇中也提到过，ES6语法声明的变量是不会挂载在全局对象上的～</p>\n<p>Array.from()</p>\n<p>Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（对象包括ES6新增的数据结构Set和Map）。</p>\n<p>&#x2F;&#x2F; 类数组转化成数组<br>let arrayLike &#x3D; {<br>    ‘0’: ‘a’,<br>    ‘1’: ‘b’,<br>    ‘2’: ‘c’,<br>    length: 3<br>}</p>\n<p>&#x2F;&#x2F; ES5的写法<br>var arr1 &#x3D; [].slice.call(arrayLike); &#x2F;&#x2F; [‘a’, ‘b’, ‘c’]</p>\n<p>&#x2F;&#x2F; ES6的写法<br>let arr2 &#x3D; Array.from(arrayLike); &#x2F;&#x2F; [‘a’, ‘b’, ‘c’]<br>Array.of()</p>\n<p>Array.of()方法用于将一组值，转换为数组。</p>\n<p>let arr &#x3D; Array.of(2, 3, ‘reng’);<br>console.log(arr); &#x2F;&#x2F; [2, 3, ‘reng’]<br>console.log(arr.pop()); &#x2F;&#x2F; reng<br>Array.of基本上可以弥补Array()或new Array()带来的因为参数个数导致的不同行为。Array.of基本上可以替代它们两个了。</p>\n<p>Array.of(); &#x2F;&#x2F; []<br>Array.of(‘reng’); &#x2F;&#x2F; [‘reng’]<br>Array.of(2, ‘reng’); &#x2F;&#x2F; [2, ‘reng’]<br>数组中还有其它有用的方法：</p>\n<p>copyWithin(target, start &#x3D; 0, end &#x3D; this.length): 拷贝指定数组的范围值<br>find(fn): 用于查找第一个符合条件的数组成员，没有返回undefined<br>findIndex(fn): 用于查找第一个符合条件的数组成员的位置，没有返回-1<br>entries(): 对键值对的遍历<br>keys(): 对键的遍历<br>values(): 对值的遍历<br>includes(el): 返回一个布尔值，表示某个数组是否包含给定的值，与字符串的include(el)方法相似<br>flat(num): 将嵌套的数组拉平，num是遍历的深度<br>[1, [2, [3]]].flat(Infinity);<br>&#x2F;&#x2F; [1, 2, 3]<br>有这么一个需求：将数组[[2, 8], [2], [[4, 6], 7, 6]]转成一维且元素不重复的数组。</p>\n<p>我们的实现方案如下：</p>\n<p>let arr &#x3D; [[2, 8], [2], [[4, 6], 7, 6]];<br>console.log([…new Set(arr.flat(Infinity))]); &#x2F;&#x2F; [2, 8, 4, 6, 7]<br>对象扩展</p>\n<p>属性名表达式</p>\n<p>ES6允许字面量定义对象时，把表达式放在方括号内：</p>\n<p>let lastWord &#x3D; ‘last word’;</p>\n<p>const a &#x3D; {<br>  ‘first word’: ‘hello’,<br>  [lastWord]: ‘world’,<br>  [‘end’+’symbol’]: ‘!’<br>};</p>\n<p>a[‘first word’] &#x2F;&#x2F; ‘hello’<br>a[lastWord] &#x2F;&#x2F; ‘world’<br>a[‘last word’] &#x2F;&#x2F; ‘world’<br>a[‘endsymbol’] &#x2F;&#x2F; ‘!’<br>对象的扩展运算符</p>\n<p>上面整理数组扩展内容的时候，提到了数组的扩展运算符。ES2018将这个运算符引入了对象～</p>\n<p>let z &#x3D; { a: 3, b: 4 };<br>let n &#x3D; { …z }; &#x2F;&#x2F; 关键点<br>n &#x2F;&#x2F; { a: 3, b: 4 }<br>对象中某些新增的方法</p>\n<p>Object.is(arg1, arg2): 比较两个值是否严格相等，与&#x3D;&#x3D;&#x3D;行为基本一致<br>Object.assign(target, source1, …): 用于对象的合并，将源对象(source)的所有可枚举属性，复制到目标对象(target)。属于浅拷贝<br>Object.keys(obj): 返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名<br>Object.values(obj): 方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。<br>Object.entries(obj): 方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。<br>const obj &#x3D; { foo: ‘bar’, baz: 42 };<br>Object.entries(obj)<br>&#x2F;&#x2F; [ [“foo”, “bar”], [“baz”, 42] ]<br>Set和Map数据结构</p>\n<p>Set</p>\n<p>Set翻译出来就是集合，有元素唯一性的特点。</p>\n<p>在数组去重的场景上很有用处：</p>\n<p>&#x2F;&#x2F; 去除数组的重复成员<br>[…new Set(array)]<br>&#x2F;&#x2F; 如<br>console.log([…new Set([2, 2, 3, 2])]); &#x2F;&#x2F; [2, 3]<br>需要留意的Set属性和方法有以下：</p>\n<p>size: 返回实例成员的总数<br>add(value): 添加某个值，返回Set结构本身<br>delete(value): 删除某个值，返回一个布尔值，表示删除是否成功。<br>has(value): 返回一个布尔值，表示该值是否为Set的成员<br>clear(): 清除所有成员，没有返回值。<br>key():返回键名的遍历器。<br>values(): 返回键值的遍历器。<br>entries(): 返回键值对的遍历器。<br>forEach(): 使用回调函数遍历每个成员<br>WeakSet</p>\n<p>WeakSet结构与Set类似，也是有不重复元素的集合。但是它和Set有两个区别：</p>\n<p>WeakSet对象中只能存放对象引用, 不能存放值, 而Set对象都可以.</p>\n<p>WeakSet中对象中存储的对象值都是被弱引用的, 如果没有其他的变量或属性引用这个对象值, 则这个对象值会被当成垃圾回收掉. 正因为这样, WeakSet 对象是无法被枚举的, 没有办法拿到它包含的所有元素。</p>\n<p>var ws &#x3D; new WeakSet();<br>var obj &#x3D; {};<br>var foo &#x3D; {};</p>\n<p>ws.add(window);<br>ws.add(obj);</p>\n<p>ws.has(window); &#x2F;&#x2F; true<br>ws.has(foo);    &#x2F;&#x2F; false, 对象 foo 并没有被添加进 ws 中 </p>\n<p>ws.delete(window); &#x2F;&#x2F; 从集合中删除 window 对象<br>ws.has(window);    &#x2F;&#x2F; false, window 对象已经被删除了</p>\n<p>ws.clear(); &#x2F;&#x2F; 清空整个 WeakSet 对象<br>WeakSet 没有size属性，没有办法遍历它的成员。</p>\n<p>Map</p>\n<p>Map对象保持键值对。任何值（对象或者原始值）都可以作为一个键或一个值。</p>\n<p>Object和Map的比较：</p>\n<p>一个Object的键只能是字符串或者Symbols，但一个Map的键可以是任意值，包括函数、对象、基本类型。<br>Map中的键值是有序的，而添加到对象中的键则不是。因此，当对它进行遍历时，Map对象是按插入的顺序返回键值。<br>Map在涉及频繁增删键值对的场景下会有些性能优势&#96;。<br>…<br>如果你需要“键值对”的数据结构，Map比Object更合适。</p>\n<p>const set &#x3D; new Set([ &#x2F;&#x2F; 数组转换为map<br>  [‘foo’, 1],<br>  [‘bar’, 2]<br>]);<br>const m1 &#x3D; new Map(set);<br>m1.get(‘foo’) &#x2F;&#x2F; 1</p>\n<p>const m2 &#x3D; new Map([[‘baz’, 3]]);<br>const m3 &#x3D; new Map(m2);<br>m3.get(‘baz’) &#x2F;&#x2F; 3<br>Map拥有的属性和方法和Set相似，多出了些：</p>\n<p>set(key, value)：set方法设置键名key对应的键值为value，然后返回整个 Map 结构。如果key已经有值，则键值会被更新，否则就新生成该键。<br>get(key)：get方法读取key对应的键值，如果找不到key，返回undefined<br>WeakMap</p>\n<p>WeakMap结构与Map结构类似，也是用于生成键值对的集合。但是有两点区别：</p>\n<p>WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。<br>WeakMap的键名所指向的对象，不计入垃圾回收机制。和WeakSet相似啦。<br>属性方法啥的跟Map差不多，就是没有了size和forEach，因为其是不可枚举的。</p>\n<p>Promise对象</p>\n<p>Promise是异步编程的一种解决方案，比传统的解决方案“回调函数和事件”更合理和更强大。</p>\n<p>Promise对象有以下两个特点：</p>\n<p>对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。</p>\n<p>一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种情况：从pending变成fulfilled（fulfilled也称resolved）和从pending变成rejected。</p>\n<p>用法</p>\n<p>const promise &#x3D; new Promise(function(resolve, reject) {<br>    &#x2F;&#x2F; …some code</p>\n<pre><code>if(/* 异步操作成功 */) &#123;\n    resolve(value);\n&#125; else &#123;\n    reject(error);\n&#125;\n</code></pre>\n<p>})<br>参数resolve和reject是两个函数，由JavaScript引擎提供，不用自己部署。</p>\n<p>Promise实例生成之后，可以使用then方法分别指定resolved状态和rejected状态的回调函数。</p>\n<p>promise.then(function(value) {<br>    &#x2F;&#x2F; success<br>}, function(error) {<br>    &#x2F;&#x2F; failure<br>});<br>我们来粘贴个简单例子：</p>\n<p>function timeout(ms) {<br>    return new Promise((resolve, reject) &#x3D;&gt; {<br>        setTimeout(resolve, ms, ‘done’);<br>    });<br>}</p>\n<p>timeout(100).then((value) &#x3D;&gt; {<br>    console.log(value); &#x2F;&#x2F; 100ms后输出’done’<br>});<br>嗯～我们顺道来复习下setTimeout的第三个参数。哦 ，不，是第三个，第四个…</p>\n<p>var timeoutID &#x3D; scope.setTimeout(function[, delay, param1, param2, …]);<br>function 是你想要在到期时间（delay毫秒）之后执行的函数。<br>delay 是可选语法，表示延迟的毫秒数。<br>param1, …, paramN 是可选的附加参数，一旦定时器到期，它们会作为参数传递给function<br>那么，到这里你理解了上面的例子为什么在100ms后输出done了嘛</p>\n<p>详细的setTimeout信息，请戳MDN的setTimeout。</p>\n<p>简单的例子看完了，看下我们在工作中使用得比较多的请求接口的例子：</p>\n<p>const getJSON &#x3D; function(url) {<br>    const promise &#x3D; new Promise(function(resolve, reject){<br>        const handler &#x3D; function() {<br>            if(this.readyState !&#x3D;&#x3D; 4) {<br>                return;<br>            }<br>            if(this.status &#x3D;&#x3D;&#x3D; 200) {<br>                resolve(this.response); &#x2F;&#x2F; this.response作为参数传给then中的json<br>            } else {<br>                reject(new Error(this.statusText));<br>            }<br>        };<br>        const client &#x3D; new XMLHttpRequest();<br>        client.open(‘GET’, url);<br>        client.onreadystatechange &#x3D; handler;<br>        client.responseType &#x3D; ‘json’;<br>        client.setRequestHeader(‘Accept’, ‘application.json’);<br>        client.send();<br>    });<br>    return promise;<br>};<br>getJSON(‘&#x2F;post.json’).then(function(json) {<br>    console.log(‘Contents: ‘+ json);<br>}, function(error) {<br>    console.log(‘error happen ‘, error);<br>});<br>catch方法</p>\n<p>Promise.prototype.catch方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。</p>\n<p>p.then((val) &#x3D;&gt; console.log(‘fulfilled:’, val))<br>    .catch((err) &#x3D;&gt; console.log(‘rejected’, err)); &#x2F;&#x2F; promise中任何一个抛出错误，都会被最后一个catch捕获</p>\n<p>&#x2F;&#x2F; 等同于<br>p.then((val) &#x3D;&gt; console.log(‘fulfilled:’, val))<br>    .then(null, (err) &#x3D;&gt; console.log(‘rejected:’, err));<br>finally方法</p>\n<p>Promise.prototype.finally()方法（其不接受任何参数）用于指定不管Promise对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。</p>\n<p>语法：</p>\n<p>promise<br>    .then(result &#x3D;&gt; {···})<br>    .catch(error &#x3D;&gt; {···})<br>    .finally(() &#x3D;&gt; {···});<br>Promise.all</p>\n<p>构造函数方法Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例。</p>\n<p>const p &#x3D; Promise.all([p1, p2, p3]);<br>上面代码中，Promise.all方法接受一个数组作为参数，p1, p2, p3都是Promise实例。如果不是会调用Promise.resolve方法，具体看文档。</p>\n<p>&#x2F;&#x2F; 生成一个Promise对象的数组<br>const promises &#x3D; [2, 3, 5, 7, 11, 13].map(function (id) {<br>    return getJSON(‘&#x2F;post&#x2F;‘ + id + “.json”);<br>});</p>\n<p>Promise.all(promises).then(function (posts) {<br>    &#x2F;&#x2F; …<br>}).catch(function(reason){<br>    &#x2F;&#x2F; …<br>});<br>上面代码中，promises是包含 6 个 Promise 实例的数组，只有这6个实例的状态都变成fulfilled，或者其中有一个变为rejected，才会调用Promise.all方法后面的回调函数。</p>\n<p>⚠️注意，如果作为参数的Promise实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法。所以使用Promise.all()别手痒在每个实例promise内添加错误捕获。</p>\n<p>一道练手题</p>\n<p>需求：使用promise改写下面的代码，使得输出的期望结果是每隔一秒输出0, 1, 2, 3, 4, 5，其中i &lt; 5条件不能变</p>\n<p>for(var i &#x3D; 0 ; i &lt; 5; i++){<br>    setTimeout(function(){<br>        console.log(i);<br>    },1000)<br>}<br>console.log(i);<br>我们直接上使用promise改写的代码吧～</p>\n<p>const tasks &#x3D; []; &#x2F;&#x2F; 存放promise对象<br>for(let i &#x3D; 0; i &lt; 5; i++){<br>    tasks.push(new Promise((resolve) &#x3D;&gt; {<br>        setTimeout(() &#x3D;&gt; {<br>            console.log(i);<br>            resolve();<br>        }, 1000 * i);<br>    }));<br>}<br>Promise.all(tasks).then(() &#x3D;&gt; {<br>    setTimeout(() &#x3D;&gt; {<br>        console.log(tasks.length);<br>    }, 1000);<br>});<br>&#x2F;&#x2F; 每隔一秒输出 0, 1, 2, 3, 4, 5<br>参考和后话</p>\n<p>阮一峰的ES6教程<br>codepen 代码验证<br>本次的ES6语法的汇总总共分为上、中、下三篇，本篇文章为中篇。</p>\n<p>谈谈ES6语法（汇总上篇）<br>文章首发在github上–谈谈ES6语法（汇总中篇）。更多的内容，请戳我的博客进行了解，能留个star就更好了</p>\n","feature":true,"text":"本次的ES6语法的汇总总共分为上、中、下三篇，本篇文章为中篇。 汇总上篇文章请戳这里–谈谈ES6语法（汇总上篇） 好了，我们直奔中篇的内容～ 数组扩展 数组扩展运算符 数组扩展运算符（spread）是三个点（…）。它好比rest参数的逆运算，将一个数组转为用空格分隔的参数序列。 ...","link":"","photos":[],"count_time":{"symbolsCount":"9.1k","symbolsTime":"8 mins."},"categories":[{"name":"前端","slug":"前端","count":3,"path":"api/categories/前端.json"},{"name":"Javascript","slug":"前端/Javascript","count":3,"path":"api/categories/前端/Javascript.json"}],"tags":[{"name":"ES6","slug":"ES6","count":3,"path":"api/tags/ES6.json"},{"name":"Javascript","slug":"Javascript","count":3,"path":"api/tags/Javascript.json"}],"toc":"","author":{"name":"Abner","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Abner223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"mapped":true,"prev_post":{"title":"ES6总结（上）","uid":"a5237b480be45e0469c9d124561aa992","slug":"ES6总结（上）","date":"2023-02-15T03:05:41.000Z","updated":"2023-02-15T03:09:51.476Z","comments":true,"path":"api/articles/ES6总结（上）.json","keywords":null,"cover":"https://source.unsplash.com/ukzHlkoz1IE/1200x628","text":" 作者：JowayYoung仓库：Github、CodePen博客：官网、掘金、思否、知乎公众号：IQ前端特别声明：原创不易，未经授权不得转载或抄袭，如需转载可联系笔者授权 前言第三次阅读阮一峰老师的《ES6标准入门》了，以前阅读时不细心，很多地方都是一目十行。最近这次阅读都是逐...","link":"","photos":[],"count_time":{"symbolsCount":"32k","symbolsTime":"29 mins."},"categories":[{"name":"前端","slug":"前端","count":3,"path":"api/categories/前端.json"},{"name":"Javascript","slug":"前端/Javascript","count":3,"path":"api/categories/前端/Javascript.json"}],"tags":[{"name":"ES6","slug":"ES6","count":3,"path":"api/tags/ES6.json"},{"name":"Javascript","slug":"Javascript","count":3,"path":"api/tags/Javascript.json"}],"author":{"name":"Abner","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Abner223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"feature":true},"next_post":{"title":"ES6总结（下）","uid":"94921aa9a74f7374b2a5c0d12ec8143a","slug":"ES6总结（下）","date":"2023-02-15T03:05:41.000Z","updated":"2023-02-15T03:11:09.553Z","comments":true,"path":"api/articles/ES6总结（下）.json","keywords":null,"cover":"https://source.unsplash.com/N4wqYiRZrLI/1200x628","text":"本次的ES6语法的汇总总共分为上、中、下三篇，本篇文章为下篇。 往期系列文章： 谈谈ES6语法（汇总上篇）谈谈ES6语法（汇总中篇）客套话不多说了，直奔下篇的内容～ async函数 ES2017标准引入了async函数，使得异步操作更加方便。async函数是Generator函数...","link":"","photos":[],"count_time":{"symbolsCount":"7.3k","symbolsTime":"7 mins."},"categories":[{"name":"前端","slug":"前端","count":3,"path":"api/categories/前端.json"},{"name":"Javascript","slug":"前端/Javascript","count":3,"path":"api/categories/前端/Javascript.json"}],"tags":[{"name":"ES6","slug":"ES6","count":3,"path":"api/tags/ES6.json"},{"name":"Javascript","slug":"Javascript","count":3,"path":"api/tags/Javascript.json"}],"author":{"name":"Abner","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Abner223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"feature":true}}