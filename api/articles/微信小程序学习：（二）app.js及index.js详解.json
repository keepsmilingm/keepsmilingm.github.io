{"title":"微信小程序:app.js及index.js详解","uid":"3544a0d90b0e0c3822563e88d582f926","slug":"微信小程序学习：（二）app.js及index.js详解","date":"2023-03-10T06:35:07.000Z","updated":"2023-10-10T09:42:30.897Z","comments":true,"path":"api/articles/微信小程序学习：（二）app.js及index.js详解.json","keywords":null,"cover":"https://img-blog.csdnimg.cn/20200401220041648.gif","content":"<h2 id=\"1、app-js\"><a href=\"#1、app-js\" class=\"headerlink\" title=\"1、app.js\"></a>1、app.js</h2><p>这是小程序的入口，启动小程序时首先调用app.js。</p>\n<p>App()注册小程序，然后内部按生命周期执行。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token comment\">//app.js//注册小程序App(&#123;   onLaunch: function () &#123;     console.log(\"app.js初始化\")    // 展示本地存储能力    // 往本地存储写入log数据，登录日志    var logs = wx.getStorageSync('logs') || []    logs.unshift(Date.now())    wx.setStorageSync('logs', logs)    // 登录    // 用户登录小程序    wx.login(&#123;       success: res => &#123;         // 登录成功后的回调        // 发送 res.code 到后台换取 openId, sessionKey, unionId        console.log('wx.login登录成功')      &#125;    &#125;)    // 重点在这    // 获取用户的设置，返回用户的授权信息    // 判断用户是否授权，若已经授权，调用wx.getUserInfo接口获取用户信息，    // 将获取的信息存到全局状态this.globalData.userInfo    // 若用户未授权，直接逃过，进入index页面    wx.getSetting(&#123;       success: res => &#123;         // 获取成功的回调        console.log('获取用户的当前设置,返回授权后的信息')        console.log(res)        //判断用户是否授权        if (res.authSetting['scope.userInfo']) &#123;           // 已经授权，则无需重复授权          // 可以直接调用 wx.getUserInfo 获取用户信息，不会弹框          console.log(\"用户已经授权\")          wx.getUserInfo(&#123;             success: res => &#123;               // 获取用户信息成功后的回调              // 可以将 res 发送给后台解码出 unionId              // 将用户信息赋值给this.globalData.userInfo              this.globalData.userInfo = res.userInfo              console.log('app.js中获取用户信息成功')              console.log(this.globalData.userInfo)              // 由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回              // 所以此处加入 callback 以防止这种情况              // app.userInfoReadyCallback是在index的onLoad函数中定义的              // 判断userInfoReadyCallback这个属性是否存在              // 如果存在，则执行，将用户数据赋值给globalData及index中的data              if (this.userInfoReadyCallback) &#123;                 this.userInfoReadyCallback(res)              &#125;            &#125;          &#125;)        &#125;      &#125;    &#125;)  &#125;,  // 全局状态  globalData: &#123;     userInfo: null  &#125;&#125;)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>（1）在onLoad函数中，首先将小程序的登录日志写入到本地。</p>\n<p>每加载一次小程序，就写入一次。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// 展示本地存储能力    // 往本地存储写入log数据，登录日志    var logs = wx.getStorageSync('logs') || []    logs.unshift(Date.now())    wx.setStorageSync('logs', logs)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>（2）小程序登录。</p>\n<p>调用wx.login接口，换取 openId, sessionKey, unionId</p>\n<p>有后端API才有用，这里没有后端，所以只打印了一下</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 登录    &#x2F;&#x2F; 用户登录小程序    wx.login(&#123;       success: res &#x3D;&gt; &#123;         &#x2F;&#x2F; 登录成功后的回调        &#x2F;&#x2F; 发送 res.code 到后台换取 openId, sessionKey, unionId        console.log(&#39;wx.login登录成功&#39;)      &#125;    &#125;)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>（3）读取用户信息。</p>\n<p>wx.getSetting()获取用户设置（返回用户的已授权信息）</p>\n<p>若已授权（res.authSetting[‘scope.userInfo’]存在），通过wx.getUserInfo调用用户信息。调用成功后，写入全局状态this.globalData.userInfo，然后index页面中通过onLoad函数调用globalData.userInfo，在index页面显示用户信息。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 重点在这    &#x2F;&#x2F; 获取用户的设置，返回用户的已授权信息    &#x2F;&#x2F; 判断用户是否授权，若已经授权，调用wx.getUserInfo接口获取用户信息，    &#x2F;&#x2F; 将获取的信息存到全局状态this.globalData.userInfo    &#x2F;&#x2F; 若用户未授权，直接逃过，进入index页面    wx.getSetting(&#123;       success: res &#x3D;&gt; &#123;         &#x2F;&#x2F; 获取成功的回调        console.log(&#39;获取用户的当前设置,返回授权后的信息&#39;)        console.log(res)        &#x2F;&#x2F;判断用户是否授权        if (res.authSetting[&#39;scope.userInfo&#39;]) &#123;           &#x2F;&#x2F; 已经授权，则无需重复授权          &#x2F;&#x2F; 可以直接调用 wx.getUserInfo 获取用户信息，不会弹框          console.log(&quot;用户已经授权&quot;)          wx.getUserInfo(&#123;             success: res &#x3D;&gt; &#123;               &#x2F;&#x2F; 获取用户信息成功后的回调              &#x2F;&#x2F; 可以将 res 发送给后台解码出 unionId              &#x2F;&#x2F; 将用户信息赋值给this.globalData.userInfo              this.globalData.userInfo &#x3D; res.userInfo              console.log(&#39;app.js中获取用户信息成功&#39;)              console.log(this.globalData.userInfo)              &#x2F;&#x2F; 由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回              &#x2F;&#x2F; 所以此处加入 callback 以防止这种情况              &#x2F;&#x2F; app.userInfoReadyCallback是在index的onLoad函数中定义的              &#x2F;&#x2F; 判断userInfoReadyCallback这个属性是否存在              &#x2F;&#x2F; 如果存在，则执行，将用户数据赋值给globalData及index中的data              if (this.userInfoReadyCallback) &#123;                 this.userInfoReadyCallback(res)              &#125;            &#125;          &#125;)        &#125;      &#125;    &#125;)  &#125;,<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>但这里有一个问题，如果index页面加载完了，wx.getUserInfo才返回数据怎么办？</p>\n<p>因为wx.getUserInfo是通过网络异步获取用户数据，无法保证一定在index页面加载之前就能获取到啊。</p>\n<p>这里就用了userInfoReadyCallback函数，这个函数是在index的onLoad函数定义的。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">app.userInfoReadyCallback &#x3D; res &#x3D;&gt; &#123;         this.setData(&#123;           userInfo: res.userInfo,          hasUserInfo: true        &#125;)      &#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>就是一个简单的赋值函数，将res赋值给index中的data。</p>\n<p>而在app.js中的wx.getUserInfo中判断app.userInfoReadyCallback是否存在，如果存在，那么就说明index中的onload函数已经为app写入了userInfoReadyCallback方法，也就是说wx.getUserInfo是通过网络异步获取用户数据成功，实在index加载数据之后，这时就需要调用这个方法，将wx.getUserInfo的返回信息，写入到index中的data。**</p>\n<h2 id=\"2、index-js\"><a href=\"#2、index-js\" class=\"headerlink\" title=\"2、index.js\"></a>2、index.js</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; index.js&#x2F;&#x2F; 获取应用实例&#x2F;&#x2F; 用于调用全局状态app.globalDataconst app &#x3D; getApp()&#x2F;&#x2F; 注册当前页面indexPage(&#123;   data: &#123;     motto: &#39;Hello &#39;,    userInfo: &#123; &#125;,    hasUserInfo: false,    &#x2F;&#x2F; 用于判断微信是否支持button.open-type.getUserInfo用法    canIUse: wx.canIUse(&#39;button.open-type.getUserInfo&#39;)  &#125;,  &#x2F;&#x2F; 生命周期函数，页面加载时  onLoad: function () &#123;     console.log(&#39;index.js初始化&#39;)    &#x2F;&#x2F; 判断是否已经获取到用户信息    if (app.globalData.userInfo) &#123;       &#x2F;&#x2F; 已经获取用户信息      &#x2F;&#x2F; 将用户信息赋值给userInfo      &#x2F;&#x2F; 将hasUserInfo设置为true      this.setData(&#123;         userInfo: app.globalData.userInfo,        hasUserInfo: true      &#125;)      console.log(&quot;写入data数据成功&quot;)      this.routerGo()    &#125; else if (this.data.canIUse)&#123;       &#x2F;&#x2F; 未获取到用户信息，但微信支持button.open-type.getUserInfo用法      &#x2F;&#x2F; 定义app.userInfoReadyCallback函数，      &#x2F;&#x2F; 这个函数在app.js调用      &#x2F;&#x2F; 由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回      &#x2F;&#x2F; 所以此处加入 callback 以防止这种情况      app.userInfoReadyCallback &#x3D; res &#x3D;&gt; &#123;         this.setData(&#123;           userInfo: res.userInfo,          hasUserInfo: true        &#125;)      &#125;    &#125; else &#123;       &#x2F;&#x2F; 微信不支持button.open-type.getUserInfo用法      &#x2F;&#x2F; 在没有 open-type&#x3D;getUserInfo 版本的兼容处理      wx.getUserInfo(&#123;         success: res &#x3D;&gt; &#123;           app.globalData.userInfo &#x3D; res.userInfo          this.setData(&#123;             userInfo: res.userInfo,            hasUserInfo: true          &#125;)        &#125;      &#125;)    &#125;  &#125;,  &#x2F;&#x2F; 绑定自定义点击事件getUserInfo  &#x2F;&#x2F; 获取用户信息  &#x2F;&#x2F; 回调函数，e就是用户授权后的返回值  &#x2F;&#x2F; 若用户授权，用户信息保存在e.detail.userInfo  &#x2F;&#x2F; 若用户拒绝，e.detail.userInfo为undefined  getUserInfo: function(e) &#123;     console.log(&quot;index按钮点击了，调用用户信息&quot;)    console.log(e)    console.log(e.detail.userInfo)    &#x2F;&#x2F; 将用户信息    app.globalData.userInfo &#x3D; e.detail.userInfo    this.setData(&#123;       userInfo: e.detail.userInfo,      hasUserInfo: true    &#125;)    this.routerGo()  &#125;,   &#x2F;&#x2F; 事件处理函数  bindViewTap: function() &#123;     wx.navigateTo(&#123;       url: &#39;..&#x2F;logs&#x2F;logs&#39;    &#125;)  &#125;,  &#x2F;&#x2F; 实现页面自动跳转  routerGo()&#123;     console.log(&#39;跳转函数调用了&#39;)    &#x2F;&#x2F; 定义一个周期函数interval    &#x2F;&#x2F; 判断image图片是否渲染，渲染成功后自动跳转    let interval&#x3D;setInterval( ()&#x3D;&gt; &#123;       if (wx.createSelectorQuery().select(&#39;image&#39;)) &#123;         console.log(wx.createSelectorQuery().select(&#39;image&#39;))        &#x2F;&#x2F; 跳转        &#x2F;&#x2F; 跳转成功后执行回调函数clearInterval        wx.navigateTo(&#123;           url: &#39;.&#x2F;..&#x2F;lession&#x2F;lession&#39;,          success:()&#x3D;&gt;&#123;             console.log(this)            clearInterval(interval)          &#125;,        &#125;)      &#125;    &#125;, 500)   &#125;&#125;)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>（1）获取全局应用app</p>\n<p>这样可以通过app.globalData.userInfo获取全局状态。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; index.js&#x2F;&#x2F; 获取应用实例&#x2F;&#x2F; 用于调用全局状态app.globalDataconst app &#x3D; getApp()<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>（2）通过Page（）注册当前页面。</p>\n<p>（3）其中data是index页面的数据</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token literal-property property\">data</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span>     <span class=\"token literal-property property\">motto</span><span class=\"token operator\">:</span> <span class=\"token string\">'Hello '</span><span class=\"token punctuation\">,</span>    <span class=\"token literal-property property\">userInfo</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span> <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span>    <span class=\"token literal-property property\">hasUserInfo</span><span class=\"token operator\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span>    <span class=\"token comment\">// 用于判断微信是否支持button.open-type.getUserInfo用法    canIUse: wx.canIUse('button.open-type.getUserInfo')  &#125;,</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>（4）然后执行onLoad生命周期函数。</p>\n<p> 看着复制，其实逻辑很简单。</p>\n<p>条件一：判断app.globalData.userInfo中有信息，写入data。this.routerGo()是我自己写的页面跳转函数，自动跳转到下一个页面。可忽略。</p>\n<p>条件二：判断app.globalData.userInfo中没有信息&amp;&amp;微信版本支持button.open-type.getUserInfo（this.data.canIUse）获取用户信息的方式，那么就是说wx.getUserInfo是网络请求，可能会在 Page.onLoad 之后才返回，所以定义app.userInfoReadyCallback方法，在wx.getUserInfo的成功回调中执行。</p>\n<p>条件三：判断app.globalData.userInfo中没有信息&amp;&amp;微信版本不支持，那么直接调用wx.getUserInfo（）接口。</p>\n<p>onLoad函数执行完毕。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 生命周期函数，页面加载时  onLoad: function () &#123;     console.log(&#39;index.js初始化&#39;)    &#x2F;&#x2F; 判断是否已经获取到用户信息    if (app.globalData.userInfo) &#123;       &#x2F;&#x2F; 已经获取用户信息      &#x2F;&#x2F; 将用户信息赋值给userInfo      &#x2F;&#x2F; 将hasUserInfo设置为true      this.setData(&#123;         userInfo: app.globalData.userInfo,        hasUserInfo: true      &#125;)      console.log(&quot;写入data数据成功&quot;)      this.routerGo()    &#125; else if (this.data.canIUse)&#123;       &#x2F;&#x2F; 未获取到用户信息，但微信支持button.open-type.getUserInfo用法      &#x2F;&#x2F; 定义app.userInfoReadyCallback函数，      &#x2F;&#x2F; 这个函数在app.js调用      &#x2F;&#x2F; 由于 wx.getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回      &#x2F;&#x2F; 所以此处加入 callback 以防止这种情况      app.userInfoReadyCallback &#x3D; res &#x3D;&gt; &#123;         this.setData(&#123;           userInfo: res.userInfo,          hasUserInfo: true        &#125;)      &#125;    &#125; else &#123;       &#x2F;&#x2F; 微信不支持button.open-type.getUserInfo用法      &#x2F;&#x2F; 在没有 open-type&#x3D;getUserInfo 版本的兼容处理      wx.getUserInfo(&#123;         success: res &#x3D;&gt; &#123;           app.globalData.userInfo &#x3D; res.userInfo          this.setData(&#123;             userInfo: res.userInfo,            hasUserInfo: true          &#125;)        &#125;      &#125;)    &#125;  &#125;,<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>（5）绑定捕获事件。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 事件处理函数  bindViewTap: function() &#123;     wx.navigateTo(&#123;       url: &#39;..&#x2F;logs&#x2F;logs&#39;    &#125;)  &#125;,  &#x2F;&#x2F; 绑定自定义点击事件getUserInfo  &#x2F;&#x2F; 获取用户信息  &#x2F;&#x2F; 回调函数，e就是用户授权后的返回值  &#x2F;&#x2F; 若用户授权，用户信息保存在e.detail.userInfo  &#x2F;&#x2F; 若用户拒绝，e.detail.userInfo为undefined  getUserInfo: function(e) &#123;     console.log(&quot;index按钮点击了，调用用户信息&quot;)    console.log(e)    console.log(e.detail.userInfo)    &#x2F;&#x2F; 将用户信息    app.globalData.userInfo &#x3D; e.detail.userInfo    this.setData(&#123;       userInfo: e.detail.userInfo,      hasUserInfo: true    &#125;)    this.routerGo()  &#125;,<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>（6）自定义方法，实现页面跳转。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">routerGo()&#123;     console.log(&#39;跳转函数调用了&#39;)    &#x2F;&#x2F; 定义一个周期函数interval    &#x2F;&#x2F; 判断image图片是否渲染，渲染成功后自动跳转    let interval&#x3D;setInterval( ()&#x3D;&gt; &#123;       if (wx.createSelectorQuery().select(&#39;image&#39;)) &#123;         console.log(wx.createSelectorQuery().select(&#39;image&#39;))        &#x2F;&#x2F; 跳转        &#x2F;&#x2F; 跳转成功后执行回调函数clearInterval        wx.navigateTo(&#123;           url: &#39;.&#x2F;..&#x2F;lession&#x2F;lession&#39;,          success:()&#x3D;&gt;&#123;             console.log(this)            clearInterval(interval)          &#125;,        &#125;)      &#125;    &#125;, 500)   &#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n","feature":true,"text":"1、app.js这是小程序的入口，启动小程序时首先调用app.js。 App()注册小程序，然后内部按生命周期执行。 //app.js//注册小程序App(&#123; onLaunch: function () &#123; console.log(\"app.js初始化\") /...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"Vue","slug":"Vue","count":2,"path":"api/categories/Vue.json"}],"tags":[{"name":"Vue","slug":"Vue","count":2,"path":"api/tags/Vue.json"},{"name":"缓存","slug":"缓存","count":2,"path":"api/tags/缓存.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1%E3%80%81app-js\"><span class=\"toc-text\">1、app.js</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2%E3%80%81index-js\"><span class=\"toc-text\">2、index.js</span></a></li></ol>","author":{"name":"Abner","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/keepsmilingm","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"React杂记（持续更新中）","uid":"a86028911b6e2a12ef38fa51903065cc","slug":"React","date":"2023-03-10T06:35:07.000Z","updated":"2023-10-10T09:48:44.060Z","comments":true,"path":"api/articles/React.json","keywords":null,"cover":"https://img-blog.csdnimg.cn/20200401220041648.gif","text":"ReactjsxSTATEHooks ——以 use 开头的函数——只能在组件或自定义 Hook 的最顶层调用。 你不能在条件语句、循环语句或其他嵌套函数内调用 Hook。Hook 是函数，但将它们视为关于组件需求的无条件声明会很有帮助。在组件顶部 “use” React 特性，...","link":"","photos":[],"count_time":{"symbolsCount":"4.8k","symbolsTime":"4 mins."},"categories":[{"name":"React","slug":"React","count":1,"path":"api/categories/React.json"}],"tags":[{"name":"React","slug":"React","count":1,"path":"api/tags/React.json"}],"author":{"name":"Abner","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/keepsmilingm","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"转载--js中if到底该如何判断变量为空","uid":"9097e217f4ba16fbf1d18b49b3a67940","slug":"js中if到底该如何判断变量为空","date":"2023-03-10T06:35:07.000Z","updated":"2023-10-12T08:39:46.307Z","comments":true,"path":"api/articles/js中if到底该如何判断变量为空.json","keywords":null,"cover":"https://img-blog.csdnimg.cn/10c9e558efa84a15a909733da4b48bc6.jpeg","text":"js中if到底该如何判断变量为空原文地址–js中if到底该如何判断变量为空 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 我们项目中常常需要判断一些变量是否为空,但是由于js的机制找不到很好的方法去统一判断方式，我们不妨...","link":"","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"js","slug":"js","count":5,"path":"api/categories/js.json"}],"tags":[{"name":"js","slug":"js","count":5,"path":"api/tags/js.json"}],"author":{"name":"Abner","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/keepsmilingm","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":false}}