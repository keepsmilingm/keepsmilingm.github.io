{"title":"ES6总结（下）","uid":"94921aa9a74f7374b2a5c0d12ec8143a","slug":"ES6总结（下）","date":"2023-02-15T03:05:41.000Z","updated":"2023-02-15T03:11:09.553Z","comments":true,"path":"api/articles/ES6总结（下）.json","keywords":null,"cover":"https://source.unsplash.com/N4wqYiRZrLI/1200x628","content":"<p>本次的ES6语法的汇总总共分为上、中、下三篇，本篇文章为下篇。</p>\n<p>往期系列文章：</p>\n<p>谈谈ES6语法（汇总上篇）<br>谈谈ES6语法（汇总中篇）<br>客套话不多说了，直奔下篇的内容～</p>\n<p>async函数</p>\n<p>ES2017标准引入了async函数，使得异步操作更加方便。async函数是Generator函数的语法糖。不打算写Generator函数，感兴趣的话可以看文档。与Generator返回值（Iterator对象）不同，async返回的是一个Promise对象。</p>\n<p>用法</p>\n<p>async函数返回一个Promise对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</p>\n<p>async function getStockPriceByName(name) {<br>    const symbol &#x3D; await getStockSymbol(name);<br>    const stockPrice &#x3D; await getStockPrice(symbol);<br>    return stockPrice;<br>}<br>getStockPriceByName(‘goog’).then(function(result) {<br>    console.log(result);<br>})<br>再来看几种情况加深下印象：</p>\n<p>function fun1() {<br>  console.log(‘fun1’);<br>  return ‘fun1 result’;<br>}<br>async function test() {<br>  const result1 &#x3D; await fun1();<br>  console.log(result1);<br>  console.log(‘end’);<br>}<br>test();<br>&#x2F;&#x2F; 输出<br>&#x2F;&#x2F; ‘fun1’<br>&#x2F;&#x2F; ‘fun1 result’<br>&#x2F;&#x2F; ‘end’<br>async function fun2() {<br>  console.log(‘fun2’);<br>  return ‘fun2 result’;<br>}<br>async function test() {<br>  const result2 &#x3D; await fun2();<br>  console.log(result2);<br>  console.log(‘end’);<br>}<br>test();<br>&#x2F;&#x2F; 输出<br>&#x2F;&#x2F; ‘fun2’<br>&#x2F;&#x2F; ‘fun2 result’<br>&#x2F;&#x2F; ‘end’<br>正常情况下，await命令后面是一个Promise对象，返回该对象的结果。如果不是Promise对象，就直接返回对应的值。</p>\n<p>async function fun3() {<br>  console.log(‘fun3’);<br>  setTimeout(function() {<br>    console.log(‘fun3 async’);<br>    return ‘fun3 result’;<br>  }, 1000)<br>}<br>async function test() {<br>  const result3 &#x3D; await fun3();<br>  console.log(result3);<br>  console.log(‘end’);<br>}<br>test();<br>&#x2F;&#x2F; 输出<br>&#x2F;&#x2F; ‘fun3’<br>&#x2F;&#x2F; undefined<br>&#x2F;&#x2F; ‘end’<br>&#x2F;&#x2F; ‘fun3 async’<br>async function fun4() {<br>  console.log(‘fun4’);<br>  return new Promise((resolve, reject) &#x3D;&gt; {<br>    setTimeout(() &#x3D;&gt; {<br>      console.log(‘fun4 async’);<br>      resolve(‘fun4 result’);<br>    }, 1000);<br>  })<br>}<br>async function test() {<br>  console.log(result4);<br>  console.log(‘fun4 sync’);<br>  console.log(‘end’);<br>}<br>test();<br>&#x2F;&#x2F; 输出<br>&#x2F;&#x2F; ‘fun4’<br>&#x2F;&#x2F; ‘fun4 async’<br>&#x2F;&#x2F; ‘fun4 result’<br>&#x2F;&#x2F; ‘fun4 sync’<br>&#x2F;&#x2F; ‘end’<br>模拟sleep</p>\n<p>JavaScript一直没有休眠的语法，但是借助await命令就可以让程序停顿指定的时间。【await要配合async来实现】</p>\n<p>function sleep(interval) {<br>    return new Promise(resolve &#x3D;&gt; {<br>        setTimeout(resolve, interval);<br>    })<br>}<br>&#x2F;&#x2F; use<br>async function one2FiveInAsync() {<br>    for(let i &#x3D; 1; i &lt;&#x3D; 5; i++) {<br>        console.log(i);<br>        await sleep(1000);<br>    }<br>}<br>one2FiveInAsync();<br>&#x2F;&#x2F; 1, 2, 3, 4, 5 每隔一秒输出数字<br>一道题</p>\n<p>需求：使用async await改写下面的代码，使得输出的期望结果是每隔一秒输出0, 1, 2, 3, 4, 5，其中i &lt; 5条件不能变。</p>\n<p>for(var i &#x3D; 0 ; i &lt; 5; i++){<br>    setTimeout(function(){<br>        console.log(i);<br>    },1000)<br>}<br>console.log(i);<br>之前我们讲过了用promise的方式实现，这次我们用async await方式来实现：</p>\n<p>const sleep &#x3D; (time) &#x3D;&gt; new Promise((resolve) &#x3D;&gt; {<br>    setTimeout(resolve, time);<br>});</p>\n<p>(async () &#x3D;&gt; {<br>    for(var i &#x3D; 0; i &lt; 5; i++){<br>        console.log(i);<br>        await sleep(1000);<br>    }<br>    console.log(i);<br>})();<br>&#x2F;&#x2F; 符合条件的输出 0, 1, 2, 3, 4, 5<br>比较promise和async</p>\n<p>为什么只比较promise和async呢？因为这两个用得频繁，实在的才是需要的，而且async语法是generator的语法糖，generator的说法直接戳async与其他异步处理方法的比较。</p>\n<p>两者上，async语法写法上代码量少，错误处理能力佳，而且更有逻辑语义化。</p>\n<p>假定某个 DOM 元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返回值。</p>\n<p>&#x2F;&#x2F; promise<br>function chainAnimationsPromise(elem, animations) {</p>\n<p>  &#x2F;&#x2F; 变量ret用来保存上一个动画的返回值<br>  let ret &#x3D; null;</p>\n<p>  &#x2F;&#x2F; 新建一个空的Promise<br>  let p &#x3D; Promise.resolve();</p>\n<p>  &#x2F;&#x2F; 使用then方法，添加所有动画<br>  for(let anim of animations) {<br>    p &#x3D; p.then(function(val) {<br>      ret &#x3D; val;<br>      return anim(elem);<br>    });<br>  }</p>\n<p>  &#x2F;&#x2F; 返回一个部署了错误捕捉机制的Promise<br>  return p.catch(function(e) {<br>    &#x2F;* 忽略错误，继续执行 *&#x2F;<br>  }).then(function() {<br>    return ret;<br>  });</p>\n<p>}<br>&#x2F;&#x2F; async await<br>async function chainAnimationsAsync(elem, animations) {<br>  let ret &#x3D; null;<br>  try {<br>    for(let anim of animations) {<br>      ret &#x3D; await anim(elem);<br>    }<br>  } catch(e) {<br>    &#x2F;* 忽略错误，继续执行 *&#x2F;<br>  }<br>  return ret;<br>}<br>类class</p>\n<p>在ES6之前，是使用构造函数来模拟类的，现在有了关键字class了，甚是开心</p>\n<p>function Person() {}<br>Person.prototype.sayHello &#x3D; function(){<br>    console.log(‘Hi’);<br>};<br>class Person{<br>    sayHello(){<br>        console.log(‘Hi!’);<br>    }<br>}<br>constructor方法</p>\n<p>constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法，一个类中必须有construtor方法，如果没有显式定义，一个空的constructor方法会默认添加。</p>\n<p>class Person{}<br>&#x2F;&#x2F; 等同于<br>class Person{<br>    constructor(){}<br>}<br>construtor方法也就类似构造函数，在执行new的时候，先跑构造函数，再跑到原型对象上。</p>\n<p>取值函数(getter)和存值函数(setter)</p>\n<p>与ES5一样，在类的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p>\n<p>class MyClass {<br>    get prop() {<br>        return ‘getter’;<br>    }<br>    set prop(value) {<br>        console.log(<code>setter: $&#123; value &#125;</code>)<br>    }<br>}</p>\n<p>let inst &#x3D; new MyClass();</p>\n<p>inst.prop &#x3D; 123;<br>&#x2F;&#x2F; ‘setter: 123’</p>\n<p>console.log(inst.prop);<br>&#x2F;&#x2F; ‘getter’<br>this的指向</p>\n<p>类的方法内部如果含有this，它默认是指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。</p>\n<p>class Person{<br>    constructor(job) {<br>        this.job &#x3D; job;<br>    }<br>    printJob() {<br>        console.log(<code>My job is $&#123; this.job &#125;</code>);<br>    }<br>  sayHi() {<br>    console.log(<code>I love my job -- $&#123; this.job &#125;.</code>)<br>  }<br>}<br>const person &#x3D; new Person(‘teacher’);<br>person.printJob(); &#x2F;&#x2F; ‘My job is teacher’<br>const { sayHi } &#x3D; person;<br>sayHi(); &#x2F;&#x2F; 报错: Uncaught TypeError: Cannot read property ‘job’ of undefined<br>上面的代码中，sayHi方法单独使用，this会指向该方法运行时所在的环境（由于class内部是严格模式，所以this实际上指向undefined）。</p>\n<p>修正上面的错误也很简单，也是我们在react开发中经常使用的一种手段：在调用构造函数实例化的时候直接绑定实例(this)，修改如下：</p>\n<p>class Person{<br>    constructor(job) {<br>        this.job &#x3D; job;<br>        this.sayHi &#x3D; this.sayHi.bind(this);<br>    }<br>}<br>继承</p>\n<p>ES5中继承的方式我之前有整理过–JavaScript 中的六种继承方式。</p>\n<p>ES6中的继承通过extends关键字实现，比ES5的实现继承更加清晰和方便了。</p>\n<p>class Point {<br>  constructor(x, y) {<br>    this.x &#x3D; x;<br>    this.y &#x3D; y;<br>  }<br>}</p>\n<p>class ColorPoint extends Point {<br>  constructor(x, y, color) {<br>    this.color &#x3D; color;<br>  }<br>}</p>\n<p>let cp &#x3D; new ColorPoint(25, 8, ‘green’); &#x2F;&#x2F; 报错： Must call super constructor in derived class before accessing ‘this’ or returning from derived constructor<br>上面这样写，不能继承构造函数里面的属性值和方法。需要在子类的构造函数中加上super关键字。改成下面这样即可：</p>\n<p>class Point {<br>  constructor(x, y) {<br>    this.x &#x3D; x;<br>    this.y &#x3D; y;<br>  }<br>}</p>\n<p>class ColorPoint extends Point {<br>  constructor(x, y, color) {<br>    super(x, y); &#x2F;&#x2F; 调用父类的construtor(x, y)，相当于ES5中的call。注意的是，super要放在子类构造函数的第一行<br>    this.color &#x3D; color;<br>  }<br>}</p>\n<p>let cp &#x3D; new ColorPoint(25, 8, ‘green’);<br>module模块</p>\n<p>在ES6之前，社区制定了一些模块的加载的方案，最主要的有CommonJS和AMD两种。前者用于服务器，后者用于浏览器。</p>\n<p>&#x2F;&#x2F; CommonJS<br>let { stat, exists, readFile } &#x3D; require(‘fs’);<br>ES6在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS和AMD规范，成为浏览器和服务器通用的模块解决方案。</p>\n<p>&#x2F;&#x2F; ES6模块<br>import { stat, exists, readFile } from ‘fs’;<br>各种好处详细见文档</p>\n<p>export命令</p>\n<p>export命令用于规定模块的对外接口 。</p>\n<p><strong>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。</strong>你可以理解为一个命名空间～</p>\n<p>想要获取模块里面的变量，你就需要导出export：</p>\n<p>&#x2F;&#x2F; profile.js<br>const name &#x3D; ‘jia ming’;<br>const sayHi &#x3D; function() {<br>    console.log(‘Hi!’);<br>}</p>\n<p>export { name, sayHi };<br>还有一个export default命令，方便用户（开发者啦）不用阅读文档就能加载模块（实际上就是输出一个default变量，而这个变量在import的时候是可以更改的）：</p>\n<p>&#x2F;&#x2F; export-default.js<br>export default function () {<br>  console.log(‘foo’);<br>}<br>其他模块加载该模块时，import命令可以为该匿名函数指定任意名字。</p>\n<p>&#x2F;&#x2F; import-default.js<br>import customName from ‘.&#x2F;export-default’;<br>customName(); &#x2F;&#x2F; ‘foo’<br>import命令</p>\n<p>import命令用于输入其他模块提供的功能。使用export命令定义了模块的对外接口以后，其他JS文件就可以通过import命令加载这个模块。</p>\n<p>&#x2F;&#x2F; main.js<br>import { name, sayHi } from ‘.&#x2F;profile.js’;</p>\n<p>function printName() {<br>    console.log(‘My name is ‘ + name);<br>}<br>至此，本系列文章谈谈ES6语法已经写完，希望文章对读者有点点帮助。本系列的内容是个人觉得在开发中比较重要的知识点，如果要详细内容的话，请上相关的文档查看～</p>\n<p>参考和后话</p>\n<p>阮一峰的ES6教程<br>codepen 代码验证<br>本次的ES6语法的汇总总共分为上、中、下三篇，本篇文章为下篇。</p>\n<p>谈谈ES6语法（汇总上篇）<br>谈谈ES6语法（汇总中篇）<br>系列文章至此已经完结！</p>\n<p>文章首发在github上–谈谈ES6语法（汇总下篇）。更多的内容，请戳我的博客进行了解，能留个star就更好了</p>\n","feature":true,"text":"本次的ES6语法的汇总总共分为上、中、下三篇，本篇文章为下篇。 往期系列文章： 谈谈ES6语法（汇总上篇）谈谈ES6语法（汇总中篇）客套话不多说了，直奔下篇的内容～ async函数 ES2017标准引入了async函数，使得异步操作更加方便。async函数是Generator函数...","link":"","photos":[],"count_time":{"symbolsCount":"7.3k","symbolsTime":"7 mins."},"categories":[{"name":"前端","slug":"前端","count":3,"path":"api/categories/前端.json"},{"name":"Javascript","slug":"前端/Javascript","count":3,"path":"api/categories/前端/Javascript.json"}],"tags":[{"name":"ES6","slug":"ES6","count":3,"path":"api/tags/ES6.json"},{"name":"Javascript","slug":"Javascript","count":3,"path":"api/tags/Javascript.json"}],"toc":"","author":{"name":"Abner","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Abner223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"mapped":true,"prev_post":{"title":"ES6总结（中）","uid":"788d899c6b4422522bb9706082cc38c8","slug":"ES6总结（中）","date":"2023-02-15T03:05:41.000Z","updated":"2023-02-15T03:10:10.842Z","comments":true,"path":"api/articles/ES6总结（中）.json","keywords":null,"cover":"https://img-blog.csdnimg.cn/20200401220041648.gif","text":"本次的ES6语法的汇总总共分为上、中、下三篇，本篇文章为中篇。 汇总上篇文章请戳这里–谈谈ES6语法（汇总上篇） 好了，我们直奔中篇的内容～ 数组扩展 数组扩展运算符 数组扩展运算符（spread）是三个点（…）。它好比rest参数的逆运算，将一个数组转为用空格分隔的参数序列。 ...","link":"","photos":[],"count_time":{"symbolsCount":"9.1k","symbolsTime":"8 mins."},"categories":[{"name":"前端","slug":"前端","count":3,"path":"api/categories/前端.json"},{"name":"Javascript","slug":"前端/Javascript","count":3,"path":"api/categories/前端/Javascript.json"}],"tags":[{"name":"ES6","slug":"ES6","count":3,"path":"api/tags/ES6.json"},{"name":"Javascript","slug":"Javascript","count":3,"path":"api/tags/Javascript.json"}],"author":{"name":"Abner","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/Abner223","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/ACE_U_005A","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"feature":true},"next_post":{}}