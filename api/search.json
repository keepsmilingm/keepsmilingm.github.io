[{"id":"a5237b480be45e0469c9d124561aa992","title":"ES6总结（上）","content":"  \n\n\n\n\n\n\n\n\n\n作者：JowayYoung仓库：Github、CodePen博客：官网、掘金、思否、知乎公众号：IQ前端特别声明：原创不易，未经授权不得转载或抄袭，如需转载可联系笔者授权\n前言第三次阅读阮一峰老师的《ES6标准入门》了，以前阅读时不细心，很多地方都是一目十行。最近这次阅读都是逐个逐个字来读，发现很多以前都没有注意到的知识点，为了方便记忆和预览全部ES6特性，所以写下本文。\n以下提到的《ES6标准入门》统一使用《ES6》这个名称来代替，而最新的ES6版本也是截止到当前的ES2020\n复制代码\n\n本文的知识点完全是参考或摘录《ES6》里的语句，有部分语句为了方便理解和记忆，进行了相同意思的转义，同时对知识点进行归类划分。为了让大家能集中精力来记住这些特性，全文一句废话和题外话都没有，全部模块以笔记的形式进行书写，如果看得不是很惯建议对照《ES6》的内容来学习。\n本文整理出来的笔记都是书中的精华内容，囊括了整个ES6体系的所有特性，非常方便大家重新认识全部ES6特性。半小时的阅读就可对ES6有一个全面的了解，可认为是一本ES6特性小字典，收藏后可随时查阅。即使看不完也要拉到本文末尾喔，有个大彩蛋，嘻嘻！\n\n修正ES6是ECMA为JavaScript制定的第6个标准版本，相关历史可查看此章节《ES6-ECMAScript6简介》。\n标准委员会最终决定，标准在每年6月正式发布并作为当年的正式版本，接下来的时间里就在此版本的基础上进行改动，直到下一年6月草案就自然变成新一年的版本，这样一来就无需以前的版本号，只要用年份标记即可。ECMAscript 2015是在2015年6月发布ES6的第一个版本。以此类推，ECMAscript 2016是ES6的第二个版本、 ECMAscript 2017是ES6的第三个版本。ES6既是一个历史名词也是一个泛指，含义是5.1版本以后的JavaScript下一代标准，目前涵盖了ES2015、ES2016、ES2017、ES2018、ES2019、ES2020。\n所以有些文章上提到的ES7(实质上是ES2016)、ES8(实质上是ES2017)、ES9(实质上是ES2018)、ES10(实质上是ES2019)、ES11(实质上是ES2020)，实质上都是一些不规范的概念。从ES1到ES6，每个标准都是花了好几年甚至十多年才制定下来，你一个ES6到ES7，ES7到ES8，才用了一年，按照这样的定义下去，那不是很快就ES20了。用正确的概念来说ES6目前涵盖了ES2015、ES2016、ES2017、ES2018、ES2019、ES2020。\n\n另外，ES6更新的内容主要分为以下几点\n\n表达式：声明、解构赋值\n内置对象：字符串扩展、数值扩展、对象扩展、数组扩展、函数扩展、正则扩展、Symbol、Set、Map、Proxy、Reflect\n语句与运算：Class、Module、Iterator\n异步编程：Promise、Generator、Async\n\nES2015\n声明\nconst命令：声明常量\nlet命令：声明变量\n\n\n\n\n\n\n\n\n\n\n作用\n\n作用域\n全局作用域\n函数作用域：function() &#123;&#125;\n块级作用域：&#123;&#125;\n\n\n作用范围\nvar命令在全局代码中执行\nconst命令和let命令只能在代码块中执行\n\n\n赋值使用\nconst命令声明常量后必须立马赋值\nlet命令声明变量后可立马赋值或使用时赋值\n\n\n声明方法：var、const、let、function、class、import\n\n\n\n\n\n\n\n\n\n\n重点难点\n\n不允许重复声明\n未定义就使用会报错：const命令和let命令不存在变量提升\n暂时性死区：在代码块内使用const命令和let命令声明变量之前，该变量都不可用\n\n解构赋值\n字符串解构：const [a, b, c, d, e] = &quot;hello&quot;\n数值解构：const &#123; toString: s &#125; = 123\n布尔解构：const &#123; toString: b &#125; = true\n对象解构\n形式：const &#123; x, y &#125; = &#123; x: 1, y: 2 &#125;\n默认：const &#123; x, y = 2 &#125; = &#123; x: 1 &#125;\n改名：const &#123; x, y: z &#125; = &#123; x: 1, y: 2 &#125;\n\n\n数组解构\n规则：数据结构具有Iterator接口可采用数组形式的解构赋值\n形式：const [x, y] = [1, 2]\n默认：const [x, y = 2] = [1]\n\n\n函数参数解构\n数组解构：function Func([x = 0, y = 1]) &#123;&#125;\n对象解构：function Func(&#123; x = 0, y = 1 &#125; = &#123;&#125;) &#123;&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n应用场景\n\n交换变量值：[x, y] = [y, x]\n返回函数多个值：const [x, y, z] = Func()\n定义函数参数：Func([1, 2])\n提取JSON数据：const &#123; name, version &#125; = packageJson\n定义函数参数默认值：function Func(&#123; x = 1, y = 2 &#125; = &#123;&#125;) &#123;&#125;\n遍历Map结构：for (let [k, v] of Map) &#123;&#125;\n输入模块指定属性和方法：const &#123; readFile, writeFile &#125; = require(&quot;fs&quot;)\n\n\n\n\n\n\n\n\n\n\n重点难点\n\n匹配模式：只要等号两边的模式相同，左边的变量就会被赋予对应的值\n解构赋值规则：只要等号右边的值不是对象或数组，就先将其转为对象\n解构默认值生效条件：属性值严格等于undefined\n解构遵循匹配模式\n解构不成功时变量的值等于undefined\nundefined和null无法转为对象，因此无法进行解构\n\n字符串扩展\nUnicode表示法：大括号包含表示Unicode字符(\\u&#123;0xXX&#125;或\\u&#123;0XXX&#125;)\n字符串遍历：可通过for-of遍历字符串\n字符串模板：可单行可多行可插入变量的增强版字符串\n标签模板：函数参数的特殊调用\n**String.raw()**：返回把字符串所有变量替换且对斜杠进行转义的结果\n**String.fromCodePoint()**：返回码点对应字符\n**codePointAt()**：返回字符对应码点(String.fromCodePoint()的逆操作)\n**normalize()**：把字符的不同表示方法统一为同样形式，返回新字符串(Unicode正规化)\n**repeat()**：把字符串重复n次，返回新字符串\n**matchAll()**：返回正则表达式在字符串的所有匹配\n**includes()**：是否存在指定字符串\n**startsWith()**：是否存在字符串头部指定字符串\n**endsWith()**：是否存在字符串尾部指定字符串\n\n\n\n\n\n\n\n\n\n\n重点难点\n\n以上扩展方法均可作用于由4个字节储存的Unicode字符上\n\n数值扩展\n二进制表示法：0b或0B开头表示二进制(0bXX或0BXX)\n八进制表示法：0o或0O开头表示二进制(0oXX或0OXX)\nNumber.EPSILON：数值最小精度\nNumber.MIN_SAFE_INTEGER：最小安全数值(-2^53)\nNumber.MAX_SAFE_INTEGER：最大安全数值(2^53)\n**Number.parseInt()**：返回转换值的整数部分\n**Number.parseFloat()**：返回转换值的浮点数部分\n**Number.isFinite()**：是否为有限数值\n**Number.isNaN()**：是否为NaN\n**Number.isInteger()**：是否为整数\n**Number.isSafeInteger()**：是否在数值安全范围内\n**Math.trunc()**：返回数值整数部分\n**Math.sign()**：返回数值类型(正数1、负数-1、零0)\n**Math.cbrt()**：返回数值立方根\n**Math.clz32()**：返回数值的32位无符号整数形式\n**Math.imul()**：返回两个数值相乘\n**Math.fround()**：返回数值的32位单精度浮点数形式\n**Math.hypot()**：返回所有数值平方和的平方根\n**Math.expm1()**：返回e^n - 1\n**Math.log1p()**：返回1 + n的自然对数(Math.log(1 + n))\n**Math.log10()**：返回以10为底的n的对数\n**Math.log2()**：返回以2为底的n的对数\n**Math.sinh()**：返回n的双曲正弦\n**Math.cosh()**：返回n的双曲余弦\n**Math.tanh()**：返回n的双曲正切\n**Math.asinh()**：返回n的反双曲正弦\n**Math.acosh()**：返回n的反双曲余弦\n**Math.atanh()**：返回n的反双曲正切\n\n对象扩展\n简洁表示法：直接写入变量和函数作为对象的属性和方法(&#123; prop, method() &#123;&#125; &#125;)\n属性名表达式：字面量定义对象时使用[]定义键([prop]，不能与上同时使用)\n方法的name属性：返回方法函数名\n取值函数(getter)和存值函数(setter)：get/set 函数名(属性的描述对象在get和set上)\nbind返回的函数：bound 函数名\nFunction构造函数返回的函数实例：anonymous\n\n\n属性的可枚举性和遍历：描述对象的enumerable\nsuper关键字：指向当前对象的原型对象(只能用在对象的简写方法中method() &#123;&#125;)\n**Object.is()**：对比两值是否相等\n**Object.assign()**：合并对象(浅拷贝)，返回原对象\n**Object.getPrototypeOf()**：返回对象的原型对象\n**Object.setPrototypeOf()**：设置对象的原型对象\n**__proto__**：返回或设置对象的原型对象\n\n\n\n\n\n\n\n\n\n\n属性遍历\n\n描述：自身、可继承、可枚举、非枚举、Symbol\n遍历\nfor-in：遍历对象自身可继承可枚举属性\nObject.keys()：返回对象自身可枚举属性键组成的数组\nObject.getOwnPropertyNames()：返回对象自身非Symbol属性键组成的数组\nObject.getOwnPropertySymbols()：返回对象自身Symbol属性键组成的数组\nReflect.ownKeys()：返回对象自身全部属性键组成的数组\n\n\n规则\n首先遍历所有数值键，按照数值升序排列\n其次遍历所有字符串键，按照加入时间升序排列\n最后遍历所有Symbol键，按照加入时间升序排列\n\n\n\n数组扩展\n**扩展运算符(…)**：转换数组为用逗号分隔的参数序列([...arr]，相当于rest/spread参数的逆运算)\n**Array.from()**：转换具有Iterator接口的数据结构为真正数组，返回新数组\n类数组对象：包含length的对象、Arguments对象、NodeList对象\n可遍历对象：String、Set结构、Map结构、Generator函数\n\n\n**Array.of()**：转换一组值为真正数组，返回新数组\n**copyWithin()**：把指定位置的成员复制到其他位置，返回原数组\n**find()**：返回第一个符合条件的成员\n**findIndex()**：返回第一个符合条件的成员索引值\n**fill()**：根据指定值填充整个数组，返回原数组\n**keys()**：返回以索引值为遍历器的对象\n**values()**：返回以属性值为遍历器的对象\n**entries()**：返回以索引值和属性值为遍历器的对象\n数组空位：ES6明确将数组空位转为undefined(空位处理规不一，建议避免出现)\n\n\n\n\n\n\n\n\n\n\n扩展应用\n\n克隆数组：const arr = [...arr1]\n合并数组：const arr = [...arr1, ...arr2]\n拼接数组：arr.push(...arr1)\n代替apply：Math.max.apply(null, [x, y]) &#x3D;&gt; Math.max(...[x, y])\n转换字符串为数组：[...&quot;hello&quot;]\n转换类数组对象为数组：[...Arguments, ...NodeList]\n转换可遍历对象为数组：[...String, ...Set, ...Map, ...Generator]\n与数组解构赋值结合：const [x, ...rest/spread] = [1, 2, 3]\n计算Unicode字符长度：Array.from(&quot;hello&quot;).length &#x3D;&gt; [...&quot;hello&quot;].length\n\n\n\n\n\n\n\n\n\n\n重点难点\n\n使用keys()、values()、entries()返回的遍历器对象，可用for-of自动遍历或next()手动遍历\n\n函数扩展\n参数默认值：为函数参数指定默认值\n形式：function Func(x = 1, y = 2) &#123;&#125;\n参数赋值：惰性求值(函数调用后才求值)\n参数位置：尾参数\n参数作用域：函数作用域\n声明方式：默认声明，不能用const或let再次声明\nlength：返回没有指定默认值的参数个数\n与解构赋值默认值结合：function Func(&#123; x = 1, y = 2 &#125; = &#123;&#125;) &#123;&#125;\n应用\n指定某个参数不得省略，省略即抛出错误：function Func(x = throwMissing()) &#123;&#125;\n将参数默认值设为undefined，表明此参数可省略：Func(undefined, 1)\n\n\n\n\n**rest&#x2F;spread参数(…)**：返回函数多余参数\n形式：以数组的形式存在，之后不能再有其他参数\n作用：代替Arguments对象\nlength：返回没有指定默认值的参数个数但不包括rest/spread参数\n\n\n严格模式：在严格条件下运行JS\n应用：只要函数参数使用默认值、解构赋值、扩展运算符，那么函数内部就不能显式设定为严格模式\n\n\nname属性：返回函数的函数名\n将匿名函数赋值给变量：空字符串(ES5)、变量名(ES6)\n将具名函数赋值给变量：函数名(ES5和ES6)\nbind返回的函数：bound 函数名(ES5和ES6)\nFunction构造函数返回的函数实例：anonymous(ES5和ES6)\n\n\n**箭头函数(&#x3D;&gt;)**：函数简写\n无参数：() =&gt; &#123;&#125;\n单个参数：x =&gt; &#123;&#125;\n多个参数：(x, y) =&gt; &#123;&#125;\n解构参数：(&#123;x, y&#125;) =&gt; &#123;&#125;\n嵌套使用：部署管道机制\nthis指向固定化\n并非因为内部有绑定this的机制，而是根本没有自己的this，导致内部的this就是外层代码块的this\n因为没有this，因此不能用作构造函数\n\n\n\n\n尾调用优化：只保留内层函数的调用帧\n尾调用\n定义：某个函数的最后一步是调用另一个函数\n形式：function f(x) &#123; return g(x); &#125;\n\n\n尾递归\n定义：函数尾调用自身\n作用：只要使用尾递归就不会发生栈溢出，相对节省内存\n实现：把所有用到的内部变量改写成函数的参数并使用参数默认值\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n箭头函数误区\n\n函数体内的this是定义时所在的对象而不是使用时所在的对象\n可让this指向固定化，这种特性很有利于封装回调函数\n不可当作构造函数，因此箭头函数不可使用new命令\n不可使用yield命令，因此箭头函数不能用作Generator函数\n不可使用Arguments对象，此对象在函数体内不存在(可用rest/spread参数代替)\n返回对象时必须在对象外面加上括号\n\n正则扩展\n变更RegExp构造函数入参：允许首参数为正则对象，尾参数为正则修饰符(返回的正则表达式会忽略原正则表达式的修饰符)\n正则方法调用变更：字符串对象的match()、replace()、search()、split()内部调用转为调用RegExp实例对应的RegExp.prototype[Symbol.方法]\nu修饰符：Unicode模式修饰符，正确处理大于\\uFFFF的Unicode字符\n点字符(.)\nUnicode表示法\n量词\n预定义模式\ni修饰符\n转义\n\n\ny修饰符：粘连修饰符，确保匹配必须从剩余的第一个位置开始全局匹配(与g修饰符作用类似)\nunicode：是否设置u修饰符\nsticky：是否设置y修饰符\nflags：返回正则表达式的修饰符\n\n\n\n\n\n\n\n\n\n\n重点难点\n\ny修饰符隐含头部匹配标志^\n单单一个y修饰符对match()只能返回第一个匹配，必须与g修饰符联用才能返回所有匹配\n\nSymbol\n定义：独一无二的值\n声明：const set = Symbol(str)\n入参：字符串(可选)\n方法\n**Symbol()**：创建以参数作为描述的Symbol值(不登记在全局环境)\n**Symbol.for()**：创建以参数作为描述的Symbol值，如存在此参数则返回原有的Symbol值(先搜索后创建，登记在全局环境)\n**Symbol.keyFor()**：返回已登记的Symbol值的描述(只能返回Symbol.for()的key)\n**Object.getOwnPropertySymbols()**：返回对象中所有用作属性名的Symbol值的数组\n\n\n内置\nSymbol.hasInstance：指向一个内部方法，当其他对象使用instanceof运算符判断是否为此对象的实例时会调用此方法\nSymbol.isConcatSpreadable：指向一个布尔，定义对象用于Array.prototype.concat()时是否可展开\nSymbol.species：指向一个构造函数，当实例对象使用自身构造函数时会调用指定的构造函数\nSymbol.match：指向一个函数，当实例对象被String.prototype.match()调用时会重新定义match()的行为\nSymbol.replace：指向一个函数，当实例对象被String.prototype.replace()调用时会重新定义replace()的行为\nSymbol.search：指向一个函数，当实例对象被String.prototype.search()调用时会重新定义search()的行为\nSymbol.split：指向一个函数，当实例对象被String.prototype.split()调用时会重新定义split()的行为\nSymbol.iterator：指向一个默认遍历器方法，当实例对象执行for-of时会调用指定的默认遍历器\nSymbol.toPrimitive：指向一个函数，当实例对象被转为原始类型的值时会返回此对象对应的原始类型值\nSymbol.toStringTag：指向一个函数，当实例对象被Object.prototype.toString()调用时其返回值会出现在toString()返回的字符串之中表示对象的类型\nSymbol.unscopables：指向一个对象，指定使用with时哪些属性会被with环境排除\n\n\n\n\n\n\n\n\n\n\n\n\n数据类型\n\nUndefined\nNull\nString\nNumber\nBoolean\nObject(包含Array、Function、Date、RegExp、Error)\nSymbol\n\n\n\n\n\n\n\n\n\n\n应用场景\n\n唯一化对象属性名：属性名属于Symbol类型，就都是独一无二的，可保证不会与其他属性名产生冲突\n消除魔术字符串：在代码中多次出现且与代码形成强耦合的某一个具体的字符串或数值\n遍历属性名：无法通过for-in、for-of、Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回，只能通过Object.getOwnPropertySymbols返回\n启用模块的Singleton模式：调用一个类在任何时候返回同一个实例(window和global)，使用Symbol.for()来模拟全局的Singleton模式\n\n\n\n\n\n\n\n\n\n\n重点难点\n\nSymbol()生成一个原始类型的值不是对象，因此Symbol()前不能使用new命令\nSymbol()参数表示对当前Symbol值的描述，相同参数的Symbol()返回值不相等\nSymbol值不能与其他类型的值进行运算\nSymbol值可通过String()或toString()显式转为字符串\nSymbol值作为对象属性名时，此属性是公开属性，但不是私有属性\nSymbol值作为对象属性名时，只能用方括号运算符([])读取，不能用点运算符(.)读取\nSymbol值作为对象属性名时，不会被常规方法遍历得到，可利用此特性为对象定义非私有但又只用于内部的方法\n\nSetSet\n定义：类似于数组的数据结构，成员值都是唯一且没有重复的值\n声明：const set = new Set(arr)\n入参：具有Iterator接口的数据结构\n属性\nconstructor：构造函数，返回Set\nsize：返回实例成员总数\n\n\n方法\n**add()**：添加值，返回实例\n**delete()**：删除值，返回布尔\n**has()**：检查值，返回布尔\n**clear()**：清除所有成员\n**keys()**：返回以属性值为遍历器的对象\n**values()**：返回以属性值为遍历器的对象\n**entries()**：返回以属性值和属性值为遍历器的对象\n**forEach()**：使用回调函数遍历每个成员\n\n\n\n\n\n\n\n\n\n\n\n\n应用场景\n\n去重字符串：[...new Set(str)].join(&quot;&quot;)\n去重数组：[...new Set(arr)]或Array.from(new Set(arr))\n集合数组\n声明：const a = new Set(arr1)、const b = new Set(arr2)\n并集：new Set([...a, ...b])\n交集：new Set([...a].filter(v =&gt; b.has(v)))\n差集：new Set([...a].filter(v =&gt; !b.has(v)))\n\n\n映射集合\n声明：let set = new Set(arr)\n映射：set = new Set([...set].map(v =&gt; v * 2))或set = new Set(Array.from(set, v =&gt; v * 2))\n\n\n\n\n\n\n\n\n\n\n\n\n重点难点\n\n遍历顺序：插入顺序\n没有键只有值，可认为键和值两值相等\n添加多个NaN时，只会存在一个NaN\n添加相同的对象时，会认为是不同的对象\n添加值时不会发生类型转换(5 !== &quot;5&quot;)\nkeys()和values()的行为完全一致，entries()返回的遍历器同时包括键和值且两值相等\n\nWeakSet\n定义：和Set结构类似，成员值只能是对象\n声明：const set = new WeakSet(arr)\n入参：具有Iterator接口的数据结构\n属性\nconstructor：构造函数，返回WeakSet\n\n\n方法\n**add()**：添加值，返回实例\n**delete()**：删除值，返回布尔\n**has()**：检查值，返回布尔\n\n\n\n\n\n\n\n\n\n\n\n\n应用场景\n\n储存DOM节点：DOM节点被移除时自动释放此成员，不用担心这些节点从文档移除时会引发内存泄漏\n临时存放一组对象或存放跟对象绑定的信息：只要这些对象在外部消失，它在WeakSet结构中的引用就会自动消\n\n\n\n\n\n\n\n\n\n\n重点难点\n\n成员都是弱引用，垃圾回收机制不考虑WeakSet结构对此成员的引用\n成员不适合引用，它会随时消失，因此ES6规定WeakSet结构不可遍历\n其他对象不再引用成员时，垃圾回收机制会自动回收此成员所占用的内存，不考虑此成员是否还存在于WeakSet结构中\n\nMapMap\n定义：类似于对象的数据结构，成员键是任何类型的值\n声明：const set = new Map(arr)\n入参：具有Iterator接口且每个成员都是一个双元素数组的数据结构\n属性\nconstructor：构造函数，返回Map\nsize：返回实例成员总数\n\n\n方法\n**get()**：返回键值对\n**set()**：添加键值对，返回实例\n**delete()**：删除键值对，返回布尔\n**has()**：检查键值对，返回布尔\n**clear()**：清除所有成员\n**keys()**：返回以键为遍历器的对象\n**values()**：返回以值为遍历器的对象\n**entries()**：返回以键和值为遍历器的对象\n**forEach()**：使用回调函数遍历每个成员\n\n\n\n\n\n\n\n\n\n\n\n\n重点难点\n\n遍历顺序：插入顺序\n对同一个键多次赋值，后面的值将覆盖前面的值\n对同一个对象的引用，被视为一个键\n对同样值的两个实例，被视为两个键\n键跟内存地址绑定，只要内存地址不一样就视为两个键\n添加多个以NaN作为键时，只会存在一个以NaN作为键的值\nObject结构提供字符串—值的对应，Map结构提供值—值的对应\n\nWeakMap\n定义：和Map结构类似，成员键只能是对象\n声明：const set = new WeakMap(arr)\n入参：具有Iterator接口且每个成员都是一个双元素数组的数据结构\n属性\nconstructor：构造函数，返回WeakMap\n\n\n方法\n**get()**：返回键值对\n**set()**：添加键值对，返回实例\n**delete()**：删除键值对，返回布尔\n**has()**：检查键值对，返回布尔\n\n\n\n\n\n\n\n\n\n\n\n\n应用场景\n\n储存DOM节点：DOM节点被移除时自动释放此成员键，不用担心这些节点从文档移除时会引发内存泄漏\n部署私有属性：内部属性是实例的弱引用，删除实例时它们也随之消失，不会造成内存泄漏\n\n\n\n\n\n\n\n\n\n\n重点难点\n\n成员键都是弱引用，垃圾回收机制不考虑WeakMap结构对此成员键的引用\n成员键不适合引用，它会随时消失，因此ES6规定WeakMap结构不可遍历\n其他对象不再引用成员键时，垃圾回收机制会自动回收此成员所占用的内存，不考虑此成员是否还存在于WeakMap结构中\n一旦不再需要，成员会自动消失，不用手动删除引用\n弱引用的只是键而不是值，值依然是正常引用\n即使在外部消除了成员键的引用，内部的成员值依然存在\n\nProxy\n定义：修改某些操作的默认行为\n声明：const proxy = new Proxy(target, handler)\n入参\ntarget：拦截的目标对象\nhandler：定制拦截行为\n\n\n方法\n**Proxy.revocable()**：返回可取消的Proxy实例(返回&#123; proxy, revoke &#125;，通过revoke()取消代理)\n\n\n拦截方式\n**get()**：拦截对象属性读取\n**set()**：拦截对象属性设置，返回布尔\n**has()**：拦截对象属性检查k in obj，返回布尔\n**deleteProperty()**：拦截对象属性删除delete obj[k]，返回布尔\n**defineProperty()**：拦截对象属性定义Object.defineProperty()、Object.defineProperties()，返回布尔\n**ownKeys()**：拦截对象属性遍历for-in、Object.keys()、Object.getOwnPropertyNames()、Object.getOwnPropertySymbols()，返回数组\n**getOwnPropertyDescriptor()**：拦截对象属性描述读取Object.getOwnPropertyDescriptor()，返回对象\n**getPrototypeOf()**：拦截对象原型读取instanceof、Object.getPrototypeOf()、Object.prototype.__proto__、Object.prototype.isPrototypeOf()、Reflect.getPrototypeOf()，返回对象\n**setPrototypeOf()**：拦截对象原型设置Object.setPrototypeOf()，返回布尔\n**isExtensible()**：拦截对象是否可扩展读取Object.isExtensible()，返回布尔\n**preventExtensions()**：拦截对象不可扩展设置Object.preventExtensions()，返回布尔\n**apply()**：拦截Proxy实例作为函数调用proxy()、proxy.apply()、proxy.call()\n**construct()**：拦截Proxy实例作为构造函数调用new proxy()\n\n\n\n\n\n\n\n\n\n\n\n\n应用场景\n\nProxy.revocable()：不允许直接访问对象，必须通过代理访问，一旦访问结束就收回代理权不允许再次访问\nget()：读取未知属性报错、读取数组负数索引的值、封装链式操作、生成DOM嵌套节点\nset()：数据绑定(Vue数据绑定实现原理)、确保属性值设置符合要求、防止内部属性被外部读写\nhas()：隐藏内部属性不被发现、排除不符合属性条件的对象\ndeleteProperty()：保护内部属性不被删除\ndefineProperty()：阻止属性被外部定义\nownKeys()：保护内部属性不被遍历\n\n\n\n\n\n\n\n\n\n\n重点难点\n\n要使Proxy起作用，必须针对实例进行操作，而不是针对目标对象进行操作\n没有设置任何拦截时，等同于直接通向原对象\n属性被定义为不可读写/扩展/配置/枚举时，使用拦截方法会报错\n代理下的目标对象，内部this指向Proxy代理\n\nReflect\n定义：保持Object方法的默认行为\n方法\n**get()**：返回对象属性\n**set()**：设置对象属性，返回布尔\n**has()**：检查对象属性，返回布尔\n**deleteProperty()**：删除对象属性，返回布尔\n**defineProperty()**：定义对象属性，返回布尔\n**ownKeys()**：遍历对象属性，返回数组(Object.getOwnPropertyNames()+Object.getOwnPropertySymbols())\n**getOwnPropertyDescriptor()**：返回对象属性描述，返回对象\n**getPrototypeOf()**：返回对象原型，返回对象\n**setPrototypeOf()**：设置对象原型，返回布尔\n**isExtensible()**：返回对象是否可扩展，返回布尔\n**preventExtensions()**：设置对象不可扩展，返回布尔\n**apply()**：绑定this后执行指定函数\n**construct()**：调用构造函数创建实例\n\n\n\n\n\n\n\n\n\n\n\n\n设计目的\n\n将Object属于语言内部的方法放到Reflect上\n将某些Object方法报错情况改成返回false\n让Object操作变成函数行为\nProxy与Reflect相辅相成\n\n\n\n\n\n\n\n\n\n\n废弃方法\n\nObject.defineProperty() &#x3D;&gt; Reflect.defineProperty()\nObject.getOwnPropertyDescriptor() &#x3D;&gt; Reflect.getOwnPropertyDescriptor()\n\n\n\n\n\n\n\n\n\n\n重点难点\n\nProxy方法和Reflect方法一一对应\nProxy和Reflect联合使用，前者负责拦截赋值操作，后者负责完成赋值操作\n\n\n\n\n\n\n\n\n\n\n数据绑定：观察者模式\nconst observerQueue &#x3D; new Set();\nconst observe &#x3D; fn &#x3D;&gt; observerQueue.add(fn);\nconst observable &#x3D; obj &#x3D;&gt; new Proxy(obj, &#123;\n    set(tgt, key, val, receiver) &#123;\n        const result &#x3D; Reflect.set(tgt, key, val, receiver);\n        observerQueue.forEach(v &#x3D;&gt; v());\n        return result;\n    &#125;\n&#125;);\n\nconst person &#x3D; observable(&#123; age: 25, name: &quot;Yajun&quot; &#125;);\nconst print &#x3D; () &#x3D;&gt; console.log(&#96;$&#123;person.name&#125; is $&#123;person.age&#125; years old&#96;);\nobserve(print);\nperson.name &#x3D; &quot;Joway&quot;;\n复制代码\n\nClass\n定义：对一类具有共同特征的事物的抽象(构造函数语法糖)\n原理：类本身指向构造函数，所有方法定义在prototype上，可看作构造函数的另一种写法(Class === Class.prototype.constructor)\n方法和关键字\n**constructor()**：构造函数，new命令生成实例时自动调用\nextends：继承父类\nsuper：新建父类的this\nstatic：定义静态属性方法\nget：取值函数，拦截属性的取值行为\nset：存值函数，拦截属性的存值行为\n\n\n属性\n**__proto__**：构造函数的继承(总是指向父类)\n**__proto__.__proto__**：子类的原型的原型，即父类的原型(总是指向父类的__proto__)\n**prototype.__proto__**：属性方法的继承(总是指向父类的prototype)\n\n\n静态属性：定义类完成后赋值属性，该属性不会被实例继承，只能通过类来调用\n静态方法：使用static定义方法，该方法不会被实例继承，只能通过类来调用(方法中的this指向类，而不是实例)\n继承\n实质\nES5实质：先创造子类实例的this，再将父类的属性方法添加到this上(Parent.apply(this))\nES6实质：先将父类实例的属性方法加到this上(调用super())，再用子类构造函数修改this\n\n\nsuper\n作为函数调用：只能在构造函数中调用super()，内部this指向继承的当前子类(super()调用后才可在构造函数中使用this)\n作为对象调用：在普通方法中指向父类的原型对象，在静态方法中指向父类\n\n\n显示定义：使用constructor() &#123; super(); &#125;定义继承父类，没有书写则显示定义\n子类继承父类：子类使用父类的属性方法时，必须在构造函数中调用super()，否则得不到父类的this\n父类静态属性方法可被子类继承\n子类继承父类后，可从super上调用父类静态属性方法\n\n\n\n\n实例：类相当于实例的原型，所有在类中定义的属性方法都会被实例继承\n显式指定属性方法：使用this指定到自身上(使用Class.hasOwnProperty()可检测到)\n隐式指定属性方法：直接声明定义在对象原型上(使用Class.__proto__.hasOwnProperty()可检测到)\n\n\n表达式\n类表达式：const Class = class &#123;&#125;\nname属性：返回紧跟class后的类名\n属性表达式：[prop]\nGenerator方法：* mothod() &#123;&#125;\nAsync方法：async mothod() &#123;&#125;\n\n\nthis指向：解构实例属性或方法时会报错\n绑定this：this.mothod = this.mothod.bind(this)\n箭头函数：this.mothod = () =&gt; this.mothod()\n\n\n属性定义位置\n定义在构造函数中并使用this指向\n定义在类最顶层\n\n\nnew.target：确定构造函数是如何调用\n\n\n\n\n\n\n\n\n\n\n原生构造函数\n\nString()\nNumber()\nBoolean()\nArray()\nObject()\nFunction()\nDate()\nRegExp()\nError()\n\n\n\n\n\n\n\n\n\n\n重点难点\n\n在实例上调用方法，实质是调用原型上的方法\nObject.assign()可方便地一次向类添加多个方法(Object.assign(Class.prototype, &#123; ... &#125;))\n类内部所有定义的方法是不可枚举的(non-enumerable)\n构造函数默认返回实例对象(this)，可指定返回另一个对象\n取值函数和存值函数设置在属性的Descriptor对象上\n类不存在变量提升\n利用new.target === Class写出不能独立使用必须继承后才能使用的类\n子类继承父类后，this指向子类实例，通过super对某个属性赋值，赋值的属性会变成子类实例的属性\n使用super时，必须显式指定是作为函数还是作为对象使用\nextends不仅可继承类还可继承原生的构造函数\n\n\n\n\n\n\n\n\n\n\n私有属性方法\nconst name &#x3D; Symbol(&quot;name&quot;);\nconst print &#x3D; Symbol(&quot;print&quot;);\nclass Person &#123;\n    constructor(age) &#123;\n        this[name] &#x3D; &quot;Bruce&quot;;\n        this.age &#x3D; age;\n    &#125;\n    [print]() &#123;\n        console.log(&#96;$&#123;this[name]&#125; is $&#123;this.age&#125; years old&#96;);\n    &#125;\n&#125;\n复制代码\n\n\n\n\n\n\n\n\n\n\n继承混合类\nfunction CopyProperties(target, source) &#123;\n    for (const key of Reflect.ownKeys(source)) &#123;\n        if (key !&#x3D;&#x3D; &quot;constructor&quot; &amp;&amp; key !&#x3D;&#x3D; &quot;prototype&quot; &amp;&amp; key !&#x3D;&#x3D; &quot;name&quot;) &#123;\n            const desc &#x3D; Object.getOwnPropertyDescriptor(source, key);\n            Object.defineProperty(target, key, desc);\n        &#125;\n    &#125;\n&#125;\nfunction MixClass(...mixins) &#123;\n    class Mix &#123;\n        constructor() &#123;\n            for (const mixin of mixins) &#123;\n                CopyProperties(this, new mixin());\n            &#125;\n        &#125;\n    &#125;\n    for (const mixin of mixins) &#123;\n        CopyProperties(Mix, mixin);\n        CopyProperties(Mix.prototype, mixin.prototype);\n    &#125;\n    return Mix;\n&#125;\nclass Student extends MixClass(Person, Kid) &#123;&#125;\n复制代码\n\nModule\n命令\nexport：规定模块对外接口\n默认导出：export default Person(导入时可指定模块任意名称，无需知晓内部真实名称)\n单独导出：export const name = &quot;Bruce&quot;\n按需导出：export &#123; age, name, sex &#125;(推荐)\n改名导出：export &#123; name as newName &#125;\n\n\nimport：导入模块内部功能\n默认导入：import Person from &quot;person&quot;\n整体导入：import * as Person from &quot;person&quot;\n按需导入：import &#123; age, name, sex &#125; from &quot;person&quot;\n改名导入：import &#123; name as newName &#125; from &quot;person&quot;\n自执导入：import &quot;person&quot;\n复合导入：import Person, &#123; name &#125; from &quot;person&quot;\n\n\n复合模式：export命令和import命令结合在一起写成一行，变量实质没有被导入当前模块，相当于对外转发接口，导致当前模块无法直接使用其导入变量\n默认导入导出：export &#123; default &#125; from &quot;person&quot;\n整体导入导出：export * from &quot;person&quot;\n按需导入导出：export &#123; age, name, sex &#125; from &quot;person&quot;\n改名导入导出：export &#123; name as newName &#125; from &quot;person&quot;\n具名改默认导入导出：export &#123; name as default &#125; from &quot;person&quot;\n默认改具名导入导出：export &#123; default as name &#125; from &quot;person&quot;\n\n\n\n\n继承：默认导出和改名导出结合使用可使模块具备继承性\n设计思想：尽量地静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量\n严格模式：ES6模块自动采用严格模式(不管模块头部是否添加use strict)\n\n\n\n\n\n\n\n\n\n\n模块方案\n\nCommonJS：用于服务器(动态化依赖)\nAMD：用于浏览器(动态化依赖)\nCMD：用于浏览器(动态化依赖)\nUMD：用于浏览器和服务器(动态化依赖)\nESM：用于浏览器和服务器(静态化依赖)\n\n\n\n\n\n\n\n\n\n\n加载方式\n\n运行时加载\n定义：整体加载模块生成一个对象，再从对象上获取需要的属性和方法进行加载(全部加载)\n影响：只有运行时才能得到这个对象，导致无法在编译时做静态优化\n\n\n编译时加载\n定义：直接从模块中获取需要的属性和方法进行加载(按需加载)\n影响：在编译时就完成模块加载，效率比其他方案高，但无法引用模块本身(本身不是对象)，可拓展JS高级语法(宏和类型校验)\n\n\n\n\n\n\n\n\n\n\n\n\n加载实现\n\n传统加载：通过&lt;script&gt;进行同步或异步加载脚本\n同步加载：&lt;script src=&quot;&quot;&gt;&lt;/script&gt;\nDefer异步加载：&lt;script src=&quot;&quot; defer&gt;&lt;/script&gt;(顺序加载，渲染完再执行)\nAsync异步加载：&lt;script src=&quot;&quot; async&gt;&lt;/script&gt;(乱序加载，下载完就执行)\n\n\n模块加载：&lt;script type=&quot;module&quot; src=&quot;&quot;&gt;&lt;/script&gt;(默认是Defer异步加载)\n\n\n\n\n\n\n\n\n\n\nCommonJS和ESM的区别\n\nCommonJS输出值的拷贝，ESM输出值的引用\nCommonJS一旦输出一个值，模块内部的变化就影响不到这个值\nESM是动态引用且不会缓存值，模块里的变量绑定其所在的模块，等到脚本真正执行时，再根据这个只读引用到被加载的那个模块里去取值\n\n\nCommonJS是运行时加载，ESM是编译时加载\nCommonJS加载模块是对象(即module.exports)，该对象只有在脚本运行完才会生成\nESM加载模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成\n\n\n\n\n\n\n\n\n\n\n\n\nNode加载\n\n背景：CommonJS和ESM互不兼容，目前解决方案是将两者分开，采用各自的加载方案\n区分：要求ESM采用.mjs后缀文件名\nrequire()不能加载.mjs文件，只有import命令才可加载.mjs文件\n.mjs文件里不能使用require()，必须使用import命令加载文件\n\n\n驱动：node --experimental-modules file.mjs\n限制：Node的import命令目前只支持加载本地模块(file:协议)，不支持加载远程模块\n加载优先级\n脚本文件省略后缀名：依次尝试加载四个后缀名文件(.mjs、.js、.json、node)\n以上不存在：尝试加载package.json的main字段指定的脚本\n以上不存在：依次尝试加载名称为index四个后缀名文件(.mjs、.js、.json、node)\n以上不存在：报错\n\n\n不存在的内部变量：arguments、exports、module、require、this、__dirname、__filename\nCommonJS加载ESM\n不能使用require()，只能使用import()\n\n\nESM加载CommonJS\n自动将module.exports转化成export default\nCommonJS输出缓存机制在ESM加载方式下依然有效\n采用import命令加载CommonJS模块时，不允许采用按需导入，应使用默认导入或整体导入\n\n\n\n\n\n\n\n\n\n\n\n\n循环加载\n\n定义：脚本A的执行依赖脚本B，而脚本A的执行又依赖脚本B\n加载原理\nCommonJS：require()首次加载脚本就会执行整个脚本，在内存里生成一个对象缓存下来，二次加载脚本时直接从缓存中获取\nESM：import命令加载变量不会被缓存，而是成为一个指向被加载模块的引用\n\n\n循环加载\nCommonJS：只输出已经执行的部分，还未执行的部分不会输出\nESM：需开发者自己保证真正取值时能够取到值(可把变量写成函数形式，函数具有提升作用)\n\n\n\n\n\n\n\n\n\n\n\n\n重点难点\n\nES6模块中，顶层this指向undefined，不应该在顶层代码使用this\n一个模块就是一个独立的文件，该文件内部的所有变量，外部无法获取\nexport命令输出的接口与其对应的值是动态绑定关系，即通过该接口可获取模块内部实时的值\nimport命令大括号里的变量名必须与被导入模块对外接口的名称相同\nimport命令输入的变量只读(本质是输入接口)，不允许在加载模块的脚本里改写接口\nimport命令命令具有提升效果，会提升到整个模块的头部，首先执行\n重复执行同一句import语句，只会执行一次\nexport default命令只能使用一次\nexport default命令导出的整体模块，在执行import命令时其后不能跟大括号\nexport default命令本质是输出一个名为default的变量，后面不能跟变量声明语句\nexport default命令本质是将后面的值赋给名为default的变量，可直接将值写在其后\nexport default命令和export &#123;&#125;命令可同时存在，对应复合导入\nexport命令和import命令可出现在模块任何位置，只要处于模块顶层即可，不能处于块级作用域\nimport()加载模块成功后，此模块会作为一个对象，当作then()的参数，可使用对象解构赋值来获取输出接口\n同时动态加载多个模块时，可使用Promise.all()和import()相结合来实现\nimport()和结合async/await来书写同步操作的代码\n\n\n\n\n\n\n\n\n\n\n单例模式：跨模块常量\n&#x2F;&#x2F; 常量跨文件共享\n&#x2F;&#x2F; person.js\nconst NAME &#x3D; &quot;Bruce&quot;;\nconst AGE &#x3D; 25;\nconst SEX &#x3D; &quot;male&quot;;\nexport &#123; AGE, NAME, SEX &#125;;\n复制代码\n\n&#x2F;&#x2F; file1.js\nimport &#123; AGE &#125; from &quot;person&quot;;\nconsole.log(AGE);\n复制代码\n\n&#x2F;&#x2F; file2.js\nimport &#123; AGE, NAME, SEX &#125; from &quot;person&quot;;\nconsole.log(AGE, NAME, SEX);\n复制代码\n\n\n\n\n\n\n\n\n\n\n默认导入互换整体导入\nimport Person from &quot;person&quot;;\nconsole.log(Person.AGE);\n复制代码\n\nimport * as Person from &quot;person&quot;;\nconsole.log(Person.default.AGE);\n复制代码\n\nIterator\n定义：为各种不同的数据结构提供统一的访问机制\n原理：创建一个指针指向首个成员，按照次序使用next()指向下一个成员，直接到结束位置(数据结构只要部署Iterator接口就可完成遍历操作)\n作用\n为各种数据结构提供一个统一的简便的访问接口\n使得数据结构成员能够按某种次序排列\nES6创造了新的遍历命令for-of，Iterator接口主要供for-of消费\n\n\n形式：for-of(自动去寻找Iterator接口)\n数据结构\n集合：Array、Object、Set、Map\n原生具备接口的数据结构：String、Array、Set、Map、TypedArray、Arguments、NodeList\n\n\n部署：默认部署在Symbol.iterator(具备此属性被认为可遍历的iterable)\n遍历器对象\n**next()**：下一步操作，返回&#123; done, value &#125;(必须部署)\n**return()**：for-of提前退出调用，返回&#123; done: true &#125;\n**throw()**：不使用，配合Generator函数使用\n\n\n\n\n\n\n\n\n\n\n\n\nForOf循环\n\n定义：调用Iterator接口产生遍历器对象(for-of内部调用数据结构的Symbol.iterator())\n遍历字符串：for-in获取索引，for-of获取值(可识别32位UTF-16字符)\n遍历数组：for-in获取索引，for-of获取值\n遍历对象：for-in获取键，for-of需自行部署\n遍历Set：for-of获取值 &#x3D;&gt; for (const v of set)\n遍历Map：for-of获取键值对 &#x3D;&gt; for (const [k, v] of map)\n遍历类数组：包含length的对象、Arguments对象、NodeList对象(无Iterator接口的类数组可用Array.from()转换)\n计算生成数据结构：Array、Set、Map\n**keys()**：返回遍历器对象，遍历所有的键\n**values()**：返回遍历器对象，遍历所有的值\n**entries()**：返回遍历器对象，遍历所有的键值对\n\n\n与for-in区别\n有着同for-in一样的简洁语法，但没有for-in那些缺点、\n不同于forEach()，它可与break、continue和return配合使用\n提供遍历所有数据结构的统一操作接口\n\n\n\n\n\n\n\n\n\n\n\n\n应用场景\n\n改写具有Iterator接口的数据结构的Symbol.iterator\n解构赋值：对Set进行结构\n扩展运算符：将部署Iterator接口的数据结构转为数组\nyield*：yield*后跟一个可遍历的数据结构，会调用其遍历器接口\n接受数组作为参数的函数：for-of、Array.from()、new Set()、new WeakSet()、new Map()、new WeakMap()、Promise.all()、Promise.race()\n\nPromise\n定义：包含异步操作结果的对象\n状态\n进行中：pending\n已成功：resolved\n已失败：rejected\n\n\n特点\n对象的状态不受外界影响\n一旦状态改变就不会再变，任何时候都可得到这个结果\n\n\n声明：new Promise((resolve, reject) =&gt; &#123;&#125;)\n出参\nresolve：将状态从未完成变为成功，在异步操作成功时调用，并将异步操作的结果作为参数传递出去\nreject：将状态从未完成变为失败，在异步操作失败时调用，并将异步操作的错误作为参数传递出去\n\n\n方法\n**then()**：分别指定resolved状态和rejected状态的回调函数\n第一参数：状态变为resolved时调用\n第二参数：状态变为rejected时调用(可选)\n\n\n**catch()**：指定发生错误时的回调函数\n**Promise.all()**：将多个实例包装成一个新实例，返回全部实例状态变更后的结果数组(齐变更再返回)\n入参：具有Iterator接口的数据结构\n成功：只有全部实例状态变成fulfilled，最终状态才会变成fulfilled\n失败：其中一个实例状态变成rejected，最终状态就会变成rejected\n\n\n**Promise.race()**：将多个实例包装成一个新实例，返回全部实例状态优先变更后的结果(先变更先返回)\n入参：具有Iterator接口的数据结构\n成功失败：哪个实例率先改变状态就返回哪个实例的状态\n\n\n**Promise.resolve()**：将对象转为Promise对象(等价于new Promise(resolve =&gt; resolve()))\nPromise实例：原封不动地返回入参\nThenable对象：将此对象转为Promise对象并返回(Thenable为包含then()的对象，执行then()相当于执行此对象的then())\n不具有then()的对象：将此对象转为Promise对象并返回，状态为resolved\n不带参数：返回Promise对象，状态为resolved\n\n\n**Promise.reject()**：将对象转为状态为rejected的Promise对象(等价于new Promise((resolve, reject) =&gt; reject()))\n\n\n\n\n\n\n\n\n\n\n\n\n应用场景\n\n加载图片\nAJAX转Promise对象\n\n\n\n\n\n\n\n\n\n\n重点难点\n\n只有异步操作的结果可决定当前状态是哪一种，其他操作都无法改变这个状态\n状态改变只有两种可能：从pending变为resolved、从pending变为rejected\n一旦新建Promise对象就会立即执行，无法中途取消\n不设置回调函数，内部抛错不会反应到外部\n当处于pending时，无法得知目前进展到哪一个阶段\n实例状态变为resolved或rejected时，会触发then()绑定的回调函数\nresolve()和reject()的执行总是晚于本轮循环的同步任务\nthen()返回新实例，其后可再调用另一个then()\nthen()运行中抛出错误会被catch()捕获\nreject()的作用等同于抛出错误\n实例状态已变成resolved时，再抛出错误是无效的，不会被捕获，等于没有抛出\n实例状态的错误具有冒泡性质，会一直向后传递直到被捕获为止，错误总是会被下一个catch()捕获\n不要在then()里定义rejected状态的回调函数(不使用其第二参数)\n建议使用catch()捕获错误，不要使用then()第二个参数捕获\n没有使用catch()捕获错误，实例抛错不会传递到外层代码，即不会有任何反应\n作为参数的实例定义了catch()，一旦被rejected并不会触发Promise.all()的catch()\nPromise.reject()的参数会原封不动地作为rejected的理由，变成后续方法的参数\n\nGenerator\n定义：封装多个内部状态的异步编程解决方案\n形式：调用Generator函数(该函数不执行)返回指向内部状态的指针对象(不是运行结果)\n声明：function* Func() &#123;&#125;\n方法\n**next()**：使指针移向下一个状态，返回&#123; done, value &#125;(入参会被当作上一个yield命令表达式的返回值)\n**return()**：返回指定值且终结遍历Generator函数，返回&#123; done: true, value: 入参 &#125;\n**throw()**：在Generator函数体外抛出错误，在Generator函数体内捕获错误，返回自定义的new Errow()\n\n\nyield命令：声明内部状态的值(return声明结束返回的值)\n遇到yield命令就暂停执行后面的操作，并将其后表达式的值作为返回对象的value\n下次调用next()时，再继续往下执行直到遇到下一个yield命令\n没有再遇到yield命令就一直运行到Generator函数结束，直到遇到return语句为止并将其后表达式的值作为返回对象的value\nGenerator函数没有return语句则返回对象的value为undefined\n\n\nyield*命令：在一个Generator函数里执行另一个Generator函数(后随具有Iterator接口的数据结构)\n遍历：通过for-of自动调用next()\n作为对象属性\n全写：const obj = &#123; method: function*() &#123;&#125; &#125;\n简写：const obj = &#123; * method() &#123;&#125; &#125;\n\n\n上下文：执行产生的上下文环境一旦遇到yield命令就会暂时退出堆栈(但并不消失)，所有变量和对象会冻结在当前状态，等到对它执行next()时，这个上下文环境又会重新加入调用栈，冻结的变量和对象恢复执行\n\n\n\n\n\n\n\n\n\n\n方法异同\n\n相同点：next()、throw()、return()本质上是同一件事，作用都是让函数恢复执行且使用不同的语句替换yield命令\n不同点\n**next()**：将yield命令替换成一个值\n**return()**：将yield命令替换成一个return语句\n**throw()**：将yield命令替换成一个throw语句\n\n\n\n\n\n\n\n\n\n\n\n\n应用场景\n\n异步操作同步化表达\n控制流管理\n为对象部署Iterator接口：把Generator函数赋值给对象的Symbol.iterator，从而使该对象具有Iterator接口\n作为具有Iterator接口的数据结构\n\n\n\n\n\n\n\n\n\n\n重点难点\n\n每次调用next()，指针就从函数头部或上次停下的位置开始执行，直到遇到下一个yield命令或return语句为止\n函数内部可不用yield命令，但会变成单纯的暂缓执行函数(还是需要next()触发)\nyield命令是暂停执行的标记，next()是恢复执行的操作\nyield命令用在另一个表达式中必须放在圆括号里\nyield命令用作函数参数或放在赋值表达式的右边，可不加圆括号\nyield命令本身没有返回值，可认为是返回undefined\nyield命令表达式为惰性求值，等next()执行到此才求值\n函数调用后生成遍历器对象，此对象的Symbol.iterator是此对象本身\n在函数运行的不同阶段，通过next()从外部向内部注入不同的值，从而调整函数行为\n首个next()用来启动遍历器对象，后续才可传递参数\n想首次调用next()时就能输入值，可在函数外面再包一层\n一旦next()返回对象的done为true，for-of遍历会中止且不包含该返回对象\n函数内部部署try-finally且正在执行try，那么return()会导致立刻进入finally，执行完finally以后整个函数才会结束\n函数内部没有部署try-catch，throw()抛错将被外部try-catch捕获\nthrow()抛错要被内部捕获，前提是必须至少执行过一次next()\nthrow()被捕获以后，会附带执行下一条yield命令\n函数还未开始执行，这时throw()抛错只可能抛出在函数外部\n\n\n\n\n\n\n\n\n\n\n首次next()可传值\nfunction Wrapper(func) &#123;\n    return function(...args) &#123;\n        const generator &#x3D; func(...args);\n        generator.next();\n        return generator;\n    &#125;\n&#125;\nconst print &#x3D; Wrapper(function*() &#123;\n    console.log(&#96;First Input: $&#123;yield&#125;&#96;);\n    return &quot;done&quot;;\n&#125;);\nprint().next(&quot;hello&quot;);\n复制代码\n\nES2016\n数值扩展\n**指数运算符(**)**：数值求幂(相当于Math.pow())\n\n数组扩展\n**includes()**：是否存在指定成员\n\nES2017\n声明\n共享内存和原子操作：由全局对象SharedArrayBuffer和Atomics实现，将数据存储在一块共享内存空间中，这些数据可在JS主线程和web-worker线程之间共享\n\n字符串扩展\n**padStart()**：把指定字符串填充到字符串头部，返回新字符串\n**padEnd()**：把指定字符串填充到字符串尾部，返回新字符串\n\n对象扩展\n**Object.getOwnPropertyDescriptors()**：返回对象所有自身属性(非继承属性)的描述对象\n**Object.values()**：返回以值组成的数组\n**Object.entries()**：返回以键和值组成的数组\n\n函数扩展\n函数参数尾逗号：允许函数最后一个参数有尾逗号\n\nAsync\n定义：使异步函数以同步函数的形式书写(Generator函数语法糖)\n原理：将Generator函数和自动执行器spawn包装在一个函数里\n形式：将Generator函数的*替换成async，将yield替换成await\n声明\n具名函数：async function Func() &#123;&#125;\n函数表达式：const func = async function() &#123;&#125;\n箭头函数：const func = async() =&gt; &#123;&#125;\n对象方法：const obj = &#123; async func() &#123;&#125; &#125;\n类方法：class Cla &#123; async Func() &#123;&#125; &#125;\n\n\nawait命令：等待当前Promise对象状态变更完毕\n正常情况：后面是Promise对象则返回其结果，否则返回对应的值\n后随Thenable对象：将其等同于Promise对象返回其结果\n\n\n错误处理：将await命令Promise对象放到try-catch中(可放多个)\n\n\n\n\n\n\n\n\n\n\nAsync对Generator改进\n\n内置执行器\n更好的语义\n更广的适用性\n返回值是Promise对象\n\n\n\n\n\n\n\n\n\n\n应用场景\n\n按顺序完成异步操作\n\n\n\n\n\n\n\n\n\n\n重点难点\n\nAsync函数返回Promise对象，可使用then()添加回调函数\n内部return返回值会成为后续then()的出参\n内部抛出错误会导致返回的Promise对象变为rejected状态，被catch()接收到\n返回的Promise对象必须等到内部所有await命令Promise对象执行完才会发生状态改变，除非遇到return语句或抛出错误\n任何一个await命令Promise对象变为rejected状态，整个Async函数都会中断执行\n希望即使前一个异步操作失败也不要中断后面的异步操作\n将await命令Promise对象放到try-catch中\nawait命令Promise对象跟一个catch()\n\n\nawait命令Promise对象可能变为rejected状态，最好把其放到try-catch中\n多个await命令Promise对象若不存在继发关系，最好让它们同时触发\nawait命令只能用在Async函数之中，否则会报错\n数组使用forEach()执行async/await会失效，可使用for-of和Promise.all()代替\n可保留运行堆栈，函数上下文随着Async函数的执行而存在，执行完成就消失\n\nES2018\n字符串扩展\n放松对标签模板里字符串转义的限制：遇到不合法的字符串转义返回undefined，并且从raw上可获取原字符串\n\n对象扩展\n**扩展运算符(…)**：转换对象为用逗号分隔的参数序列(&#123; ...obj &#125;，相当于rest/spread参数的逆运算)\n\n\n\n\n\n\n\n\n\n\n扩展应用\n\n克隆对象：const obj = &#123; __proto__: Object.getPrototypeOf(obj1), ...obj1 &#125;\n合并对象：const obj = &#123; ...obj1, ...obj2 &#125;\n转换字符串为对象：&#123; ...&quot;hello&quot; &#125;\n转换数组为对象：&#123; ...[1, 2] &#125;\n与对象解构赋值结合：const &#123; x, ...rest/spread &#125; = &#123; x: 1, y: 2, z: 3 &#125;(不能复制继承自原型对象的属性)\n修改现有对象部分属性：const obj = &#123; x: 1, ...&#123; x: 2 &#125; &#125;\n\n正则扩展\ns修饰符：dotAll模式修饰符，使.匹配任意单个字符(dotAll模式)\ndotAll：是否设置s修饰符\n后行断言：x只有在y后才匹配\n后行否定断言：x只有不在y后才匹配\nUnicode属性转义：匹配符合Unicode某种属性的所有字符\n正向匹配：\\p&#123;PropRule&#125;\n反向匹配：\\P&#123;PropRule&#125;\n限制：\\p&#123;...&#125;和\\P&#123;...&#125;只对Unicode字符有效，使用时需加上u修饰符\n\n\n具名组匹配：为每组匹配指定名字(?&lt;GroupName&gt;)\n形式：str.exec().groups.GroupName\n解构赋值替换\n声明：const time = &quot;2017-09-11&quot;、const regexp = /(?&lt;year&gt;\\d&#123;4&#125;)-(?&lt;month&gt;\\d&#123;2&#125;)-(?&lt;day&gt;\\d&#123;2&#125;)/u\n匹配：time.replace(regexp, &quot;$&lt;day&gt;/$&lt;month&gt;/$&lt;year&gt;&quot;)\n\n\n\n\n\nPromise\n**finally()**：指定不管最后状态如何都会执行的回调函数\n\nAsync\n**异步迭代器(for-await-of)**：循环等待每个Promise对象变为resolved状态才进入下一步\n\nES2019\n字符串扩展\n直接输入U+2028和U+2029：字符串可直接输入行分隔符和段分隔符\nJSON.stringify()改造：可返回不符合UTF-8标准的字符串\n**trimStart()**：消除字符串头部空格，返回新字符串\n**trimEnd()**：消除字符串尾部空格，返回新字符串\n\n对象扩展\n**Object.fromEntries()**：返回以键和值组成的对象(Object.entries()的逆操作)\n\n数组扩展\nsort()稳定性：排序关键字相同的项目其排序前后的顺序不变，默认为稳定\n**flat()**：扁平化数组，返回新数组\n**flatMap()**：映射且扁平化数组，返回新数组(只能展开一层数组)\n\n函数扩展\ntoString()改造：返回函数原始代码(与编码一致)\ncatch()参数可省略：catch()中的参数可省略\n\nSymbol\ndescription：返回Symbol值的描述\n\nES2020\n声明\nglobalThis：作为顶层对象，指向全局环境下的this\nBrowser：顶层对象是window\nNode：顶层对象是global\nWebWorker：顶层对象是self\n以上三者：通用顶层对象是globalThis\n\n\n\n数值扩展\nBigInt：任何位数的整数(新增的数据类型，使用n结尾)\n**BigInt()**：转换普通数值为BigInt类型\n**BigInt.asUintN()**：转换BigInt为0到2n-1之间对应的值\n**BigInt.asIntN()**：转换BigInt为-2n-1 到2n-1-1\n**BigInt.parseInt()**：近似于Number.parseInt()，将一个字符串转换成指定进制的BigInt类型\n\n\n\n\n\n\n\n\n\n\n\n\n重点难点\n\nBigInt同样可使用各种进制表示，都要加上后缀\nBigInt与普通整数是两种值，它们之间并不相等\ntypeof运算符对于BigInt类型的数据返回bigint\n\n对象扩展\n**链判断操作符(?.)**：是否存在对象属性(不存在返回undefined且不再往下执行)\n对象属性：obj?.prop、obj?.[expr]\n函数调用：func?.(...args)\n\n\n**空判断操作符(??)**：是否值为undefined或null，是则使用默认值\n\n正则扩展\n**matchAll()**：返回所有匹配的遍历器\n\nModule\n**import()**：动态导入(返回Promise)\n背景：import命令被JS引擎静态分析，先于模块内的其他语句执行，无法取代require()的动态加载功能，提案建议引入import()来代替require()\n位置：可在任何地方使用\n区别：require()是同步加载，import()是异步加载\n场景：按需加载、条件加载、模块路径动态化\n\n\n\nIterator\nfor-in遍历顺序：不同的引擎已就如何迭代属性达成一致，从而使行为标准化\n\nPromise\n**Promise.allSettled()**：将多个实例包装成一个新实例，返回全部实例状态变更后的状态数组(齐变更再返回)\n入参：具有Iterator接口的数据结构\n成功：成员包含status和value，status为fulfilled，value为返回值\n失败：成员包含status和reason，status为rejected，value为错误原因\n\n\n\nES提案\n声明\ndo表达式：封装块级作用域的操作，返回内部最后执行表达式的值(do&#123;&#125;)\nthrow表达式：直接使用throw new Error()，无需()或&#123;&#125;包括\n!#命令：指定脚本执行器(写在文件首行)\n\n数值扩展\n**数值分隔符(_)**：使用_作为千分位分隔符(增加数值的可读性)\n**Math.signbit()**：返回数值符号是否设置\n\n函数扩展\n函数部分执行：复用函数功能(?表示单个参数占位符，...表示多个参数占位符)\n**管道操作符(|&gt;)**：把左边表达式的值传入右边的函数进行求值(f(x) &#x3D;&gt; x |&gt; f)\n**绑定运算符(::)**：函数绑定(左边是对象右边是函数，取代bind、apply、call调用)\nbind：bar.bind(foo) &#x3D;&gt; foo::bar\napply：bar.apply(foo, arguments) &#x3D;&gt; foo::bar(...arguments)\n\n\n\nRealm\n定义：提供沙箱功能，允许隔离代码，防止被隔离的代码拿到全局对象\n声明：new Realm().global\n\nClass\n静态属性：使用static定义属性，该属性不会被实例继承，只能通过类来调用\n私有属性：使用#定义属性，该属性只能在类内部访问\n私有方法：使用#定义方法，该方法只能在类内部访问\n装饰器：使用@注释或修改类和类方法\n\nModule\nimport.meta：返回脚本元信息\n\nPromise\n**Promise.any()**：将多个实例包装成一个新实例，返回全部实例状态变更后的结果数组(齐变更再返回)\n入参：具有Iterator接口的数据结构\n成功：其中一个实例状态变成fulfilled，最终状态就会变成fulfilled\n失败：只有全部实例状态变成rejected，最终状态才会变成rejected\n\n\n**Promise.try()**：不想区分是否同步异步函数，包装函数为实例，使用then()指定下一步流程，使用catch()捕获错误\n\nAsync\n顶层Await：允许在模块的顶层独立使用await命令(借用await解决模块异步加载的问题)\n\n总结最后送大家一张完整的ES6特性图，记得给我点个赞喔，算是对我的一种鼓励。因为图片实在太大无法上传，请关注IQ前端或扫描文章底部二维码，后台回复ES6，获取高清的ES6全部特性记忆图，助你轻松记住ES6全部特性。\n结语❤️关注+点赞+收藏+评论+转发❤️，原创不易，鼓励笔者创作更多高质量文章\n关注公众号IQ前端，一个专注于CSS&#x2F;JS开发技巧的前端公众号，更多前端小干货等着你喔\n\n关注后回复资料免费领取学习资料\n关注后回复进群拉你进技术交流群\n欢迎关注IQ前端，更多CSS&#x2F;JS开发技巧只在公众号推送\n\n\n文章被收录于专栏：\n\nHTML&#x2F;CSS&#x2F;JS\n分享前端的基础知识与开发技巧，包含但不限于HTML&#x2F;CSS&#x2F;JS\n相关小册\n\n\nVIP\nJavaScript 设计模式核⼼原理与应⽤实践\n 5k+\n 收藏\n","slug":"ES6总结（上）","date":"2023-02-15T03:05:41.000Z","categories_index":"前端,Javascript","tags_index":"ES6,Javascript","author_index":"Abner"},{"id":"788d899c6b4422522bb9706082cc38c8","title":"ES6总结（中）","content":"本次的ES6语法的汇总总共分为上、中、下三篇，本篇文章为中篇。\n汇总上篇文章请戳这里–谈谈ES6语法（汇总上篇）\n好了，我们直奔中篇的内容～\n数组扩展数组扩展运算符数组扩展运算符（spread）是三个点（...）。它好比rest参数的逆运算，将一个数组转为用空格分隔的参数序列。\nconsole.log(...[1, 2, 3]); &#x2F;&#x2F; 1 2 3\nconsole.log(1, ...[2, 3, 4], 5); &#x2F;&#x2F; 1 2 3 4 5\n\n\n\n\n\n\n\n\n\n\n⚠️rest参数是运用在函数参数上的，将函数参数转换为数组的形式，如下：  \nfunction fn(...values) &#123;\n  console.log(values); &#x2F;&#x2F; [&#39;jia&#39;, &#39;ming&#39;]\n&#125;\nfn(&#39;jia&#39;, &#39;ming&#39;);\n\n下面我们结合数组扩展运算符和rest参数来实现一个类似call的方法call2操作：\nFunction.prototype.call2 &#x3D; function(context, ...args)&#123; &#x2F;&#x2F; 这里使用到rest参数\n    context &#x3D; context || window; &#x2F;&#x2F; 因为传递过来的context有可能是null\n    context.fn &#x3D; this; &#x2F;&#x2F; 让fn的上下文为context\n    const result &#x3D; context.fn(...args); &#x2F;&#x2F; 这里使用了数组扩展运算符\n    delete context.fn;\n    return result; &#x2F;&#x2F; 因为有可能this函数会有返回值return\n&#125;\nvar job &#x3D; &#39;outter teacher&#39;;\nvar obj &#x3D; &#123;\n    job: &#39;inner teacher&#39;\n&#125;;\nfunction showJob() &#123;\n    console.log(this.job);\n&#125;\nshowJob(); &#x2F;&#x2F; outter teacher\nshowJob.call2(obj); &#x2F;&#x2F; inner teacher\n\n复习一下，我们把var job = &#39;outter teacher&#39;改为let job = &#39;outter teacher&#39;后，showJob()会输出什么？\n答案是undefined。在前一篇中也提到过，ES6语法声明的变量是不会挂载在全局对象上的～\nArray.from()Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（对象包括ES6新增的数据结构Set和Map）。\n&#x2F;&#x2F; 类数组转化成数组\nlet arrayLike &#x3D; &#123;\n    &#39;0&#39;: &#39;a&#39;,\n    &#39;1&#39;: &#39;b&#39;,\n    &#39;2&#39;: &#39;c&#39;,\n    length: 3\n&#125;\n\n&#x2F;&#x2F; ES5的写法\nvar arr1 &#x3D; [].slice.call(arrayLike); &#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]\n\n&#x2F;&#x2F; ES6的写法\nlet arr2 &#x3D; Array.from(arrayLike); &#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]\n\nArray.of()Array.of()方法用于将一组值，转换为数组。\nlet arr &#x3D; Array.of(2, 3, &#39;reng&#39;);\nconsole.log(arr); &#x2F;&#x2F; [2, 3, &#39;reng&#39;]\nconsole.log(arr.pop()); &#x2F;&#x2F; reng\n\nArray.of基本上可以弥补Array()或new Array()带来的因为参数个数导致的不同行为。Array.of基本上可以替代它们两个了。\nArray.of(); &#x2F;&#x2F; []\nArray.of(&#39;reng&#39;); &#x2F;&#x2F; [&#39;reng&#39;]\nArray.of(2, &#39;reng&#39;); &#x2F;&#x2F; [2, &#39;reng&#39;]\n\n数组中还有其它有用的方法：\n\ncopyWithin(target, start &#x3D; 0, end &#x3D; this.length): 拷贝指定数组的范围值\nfind(fn): 用于查找第一个符合条件的数组成员，没有返回undefined\nfindIndex(fn): 用于查找第一个符合条件的数组成员的位置，没有返回-1\nentries(): 对键值对的遍历\nkeys(): 对键的遍历\nvalues(): 对值的遍历\nincludes(el): 返回一个布尔值，表示某个数组是否包含给定的值，与字符串的include(el)方法相似\nflat(num): 将嵌套的数组拉平，num是遍历的深度\n\n[1, [2, [3]]].flat(Infinity);\n&#x2F;&#x2F; [1, 2, 3]\n\n有这么一个需求：将数组[[2, 8], [2], [[4, 6], 7, 6]]转成一维且元素不重复的数组。\n我们的实现方案如下：\nlet arr &#x3D; [[2, 8], [2], [[4, 6], 7, 6]];\nconsole.log([...new Set(arr.flat(Infinity))]); &#x2F;&#x2F; [2, 8, 4, 6, 7]\n\n对象扩展属性名表达式ES6允许字面量定义对象时，把表达式放在方括号内：\nlet lastWord &#x3D; &#39;last word&#39;;\n\nconst a &#x3D; &#123;\n  &#39;first word&#39;: &#39;hello&#39;,\n  [lastWord]: &#39;world&#39;,\n  [&#39;end&#39;+&#39;symbol&#39;]: &#39;!&#39; \n&#125;;\n\na[&#39;first word&#39;] &#x2F;&#x2F; &#39;hello&#39;\na[lastWord] &#x2F;&#x2F; &#39;world&#39;\na[&#39;last word&#39;] &#x2F;&#x2F; &#39;world&#39;\na[&#39;endsymbol&#39;] &#x2F;&#x2F; &#39;!&#39;\n\n对象的扩展运算符上面整理数组扩展内容的时候，提到了数组的扩展运算符。ES2018将这个运算符引入了对象～\nlet z &#x3D; &#123; a: 3, b: 4 &#125;;\nlet n &#x3D; &#123; ...z &#125;; &#x2F;&#x2F; 关键点\nn &#x2F;&#x2F; &#123; a: 3, b: 4 &#125;\n\n对象中某些新增的方法\nObject.is(arg1, arg2): 比较两个值是否严格相等，与===行为基本一致\nObject.assign(target, source1, …): 用于对象的合并，将源对象(source)的所有可枚举属性，复制到目标对象(target)。属于浅拷贝\nObject.keys(obj): 返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名\nObject.values(obj): 方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。\nObject.entries(obj): 方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。\n\nconst obj &#x3D; &#123; foo: &#39;bar&#39;, baz: 42 &#125;;\nObject.entries(obj)\n&#x2F;&#x2F; [ [&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, 42] ]\n\nSet和Map数据结构SetSet翻译出来就是集合，有元素唯一性的特点。\n在数组去重的场景上很有用处：\n&#x2F;&#x2F; 去除数组的重复成员\n[...new Set(array)]\n&#x2F;&#x2F; 如\nconsole.log([...new Set([2, 2, 3, 2])]); &#x2F;&#x2F; [2, 3]\n\n需要留意的Set属性和方法有以下：\n\nsize: 返回实例成员的总数\nadd(value): 添加某个值，返回Set结构本身\ndelete(value): 删除某个值，返回一个布尔值，表示删除是否成功。\nhas(value): 返回一个布尔值，表示该值是否为Set的成员\nclear(): 清除所有成员，没有返回值。\nkey():返回键名的遍历器。\nvalues(): 返回键值的遍历器。\nentries(): 返回键值对的遍历器。\nforEach(): 使用回调函数遍历每个成员\n\nWeakSetWeakSet结构与Set类似，也是有不重复元素的集合。但是它和Set有两个区别：\n\nWeakSet对象中只能存放对象引用, 不能存放值, 而Set对象都可以.  \n\nWeakSet中对象中存储的对象值都是被弱引用的, 如果没有其他的变量或属性引用这个对象值, 则这个对象值会被当成垃圾回收掉. 正因为这样, WeakSet 对象是无法被枚举的, 没有办法拿到它包含的所有元素。\n\n\nvar ws &#x3D; new WeakSet();\nvar obj &#x3D; &#123;&#125;;\nvar foo &#x3D; &#123;&#125;;\n\nws.add(window);\nws.add(obj);\n\nws.has(window); &#x2F;&#x2F; true\nws.has(foo);    &#x2F;&#x2F; false, 对象 foo 并没有被添加进 ws 中 \n\nws.delete(window); &#x2F;&#x2F; 从集合中删除 window 对象\nws.has(window);    &#x2F;&#x2F; false, window 对象已经被删除了\n\nws.clear(); &#x2F;&#x2F; 清空整个 WeakSet 对象\n\nWeakSet 没有size属性，没有办法遍历它的成员。\nMapMap对象保持键值对。任何值（对象或者原始值）都可以作为一个键或一个值。\nObject和Map的比较：\n\n一个Object的键只能是字符串或者Symbols，但一个Map的键可以是任意值，包括函数、对象、基本类型。\nMap中的键值是有序的，而添加到对象中的键则不是。因此，当对它进行遍历时，Map对象是按插入的顺序返回键值。\nMap在涉及频繁增删键值对的场景下会有些性能优势`。\n…\n\n如果你需要“键值对”的数据结构，Map比Object更合适。\nconst set &#x3D; new Set([ &#x2F;&#x2F; 数组转换为map\n  [&#39;foo&#39;, 1],\n  [&#39;bar&#39;, 2]\n]);\nconst m1 &#x3D; new Map(set);\nm1.get(&#39;foo&#39;) &#x2F;&#x2F; 1\n\nconst m2 &#x3D; new Map([[&#39;baz&#39;, 3]]);\nconst m3 &#x3D; new Map(m2);\nm3.get(&#39;baz&#39;) &#x2F;&#x2F; 3\n\nMap拥有的属性和方法和Set相似，多出了些：\n\nset(key, value)：set方法设置键名key对应的键值为value，然后返回整个 Map 结构。如果key已经有值，则键值会被更新，否则就新生成该键。\nget(key)：get方法读取key对应的键值，如果找不到key，返回undefined\n\nWeakMapWeakMap结构与Map结构类似，也是用于生成键值对的集合。但是有两点区别：\n\nWeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。\nWeakMap的键名所指向的对象，不计入垃圾回收机制。和WeakSet相似啦。\n\n属性方法啥的跟Map差不多，就是没有了size和forEach，因为其是不可枚举的。\nPromise对象Promise是异步编程的一种解决方案，比传统的解决方案“回调函数和事件”更合理和更强大。\nPromise对象有以下两个特点：\n\n对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。  \n\n一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种情况：从pending变成fulfilled（fulfilled也称resolved）和从pending变成rejected。\n\n\n用法const promise &#x3D; new Promise(function(resolve, reject) &#123;\n    &#x2F;&#x2F; ...some code\n\n    if(&#x2F;* 异步操作成功 *&#x2F;) &#123;\n        resolve(value);\n    &#125; else &#123;\n        reject(error);\n    &#125;\n&#125;)\n\n参数resolve和reject是两个函数，由JavaScript引擎提供，不用自己部署。\nPromise实例生成之后，可以使用then方法分别指定resolved状态和rejected状态的回调函数。\npromise.then(function(value) &#123;\n    &#x2F;&#x2F; success\n&#125;, function(error) &#123;\n    &#x2F;&#x2F; failure\n&#125;);\n\n我们来粘贴个简单例子：\nfunction timeout(ms) &#123;\n    return new Promise((resolve, reject) &#x3D;&gt; &#123;\n        setTimeout(resolve, ms, &#39;done&#39;);\n    &#125;);\n&#125;\n\ntimeout(100).then((value) &#x3D;&gt; &#123;\n    console.log(value); &#x2F;&#x2F; 100ms后输出&#39;done&#39;\n&#125;);\n\n嗯～我们顺道来复习下setTimeout的第三个参数。哦 ，不，是第三个，第四个…\nvar timeoutID &#x3D; scope.setTimeout(function[, delay, param1, param2, ...]);\n\n\nfunction 是你想要在到期时间（delay毫秒）之后执行的函数。\ndelay 是可选语法，表示延迟的毫秒数。\nparam1, ..., paramN 是可选的附加参数，一旦定时器到期，它们会作为参数传递给function\n\n那么，到这里你理解了上面的例子为什么在100ms后输出done了嘛\n详细的setTimeout信息，请戳MDN的setTimeout。\n简单的例子看完了，看下我们在工作中使用得比较多的请求接口的例子：\nconst getJSON &#x3D; function(url) &#123;\n    const promise &#x3D; new Promise(function(resolve, reject)&#123;\n        const handler &#x3D; function() &#123;\n            if(this.readyState !&#x3D;&#x3D; 4) &#123;\n                return;\n            &#125;\n            if(this.status &#x3D;&#x3D;&#x3D; 200) &#123;\n                resolve(this.response); &#x2F;&#x2F; this.response作为参数传给then中的json\n            &#125; else &#123;\n                reject(new Error(this.statusText));\n            &#125;\n        &#125;;\n        const client &#x3D; new XMLHttpRequest();\n        client.open(&#39;GET&#39;, url);\n        client.onreadystatechange &#x3D; handler;\n        client.responseType &#x3D; &#39;json&#39;;\n        client.setRequestHeader(&#39;Accept&#39;, &#39;application.json&#39;);\n        client.send();\n    &#125;);\n    return promise;\n&#125;;\ngetJSON(&#39;&#x2F;post.json&#39;).then(function(json) &#123;\n    console.log(&#39;Contents: &#39;+ json);\n&#125;, function(error) &#123;\n    console.log(&#39;error happen &#39;, error);\n&#125;);\n\ncatch方法Promise.prototype.catch方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。\np.then((val) &#x3D;&gt; console.log(&#39;fulfilled:&#39;, val))\n    .catch((err) &#x3D;&gt; console.log(&#39;rejected&#39;, err)); &#x2F;&#x2F; promise中任何一个抛出错误，都会被最后一个catch捕获\n\n&#x2F;&#x2F; 等同于\np.then((val) &#x3D;&gt; console.log(&#39;fulfilled:&#39;, val))\n    .then(null, (err) &#x3D;&gt; console.log(&#39;rejected:&#39;, err));\n\nfinally方法Promise.prototype.finally()方法（其不接受任何参数）用于指定不管Promise对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。\n语法：\npromise\n    .then(result &#x3D;&gt; &#123;···&#125;)\n    .catch(error &#x3D;&gt; &#123;···&#125;)\n    .finally(() &#x3D;&gt; &#123;···&#125;);\n\nPromise.all构造函数方法Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例。\nconst p &#x3D; Promise.all([p1, p2, p3]);\n\n上面代码中，Promise.all方法接受一个数组作为参数，p1, p2, p3都是Promise实例。如果不是会调用Promise.resolve方法，具体看文档。\n&#x2F;&#x2F; 生成一个Promise对象的数组\nconst promises &#x3D; [2, 3, 5, 7, 11, 13].map(function (id) &#123;\n    return getJSON(&#39;&#x2F;post&#x2F;&#39; + id + &quot;.json&quot;);\n&#125;);\n\nPromise.all(promises).then(function (posts) &#123;\n    &#x2F;&#x2F; ...\n&#125;).catch(function(reason)&#123;\n    &#x2F;&#x2F; ...\n&#125;);\n\n上面代码中，promises是包含 6 个 Promise 实例的数组，只有这6个实例的状态都变成fulfilled，或者其中有一个变为rejected，才会调用Promise.all方法后面的回调函数。\n⚠️注意，如果作为参数的Promise实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法。所以使用Promise.all()别手痒在每个实例promise内添加错误捕获。\n一道练手题需求：使用promise改写下面的代码，使得输出的期望结果是每隔一秒输出0, 1, 2, 3, 4, 5，其中i &lt; 5条件不能变\nfor(var i &#x3D; 0 ; i &lt; 5; i++)&#123;\n    setTimeout(function()&#123;\n        console.log(i);\n    &#125;,1000)\n&#125;\nconsole.log(i);\n\n我们直接上使用promise改写的代码吧～\nconst tasks &#x3D; []; &#x2F;&#x2F; 存放promise对象\nfor(let i &#x3D; 0; i &lt; 5; i++)&#123;\n    tasks.push(new Promise((resolve) &#x3D;&gt; &#123;\n        setTimeout(() &#x3D;&gt; &#123;\n            console.log(i);\n            resolve();\n        &#125;, 1000 * i);\n    &#125;));\n&#125;\nPromise.all(tasks).then(() &#x3D;&gt; &#123;\n    setTimeout(() &#x3D;&gt; &#123;\n        console.log(tasks.length);\n    &#125;, 1000);\n&#125;);\n&#x2F;&#x2F; 每隔一秒输出 0, 1, 2, 3, 4, 5\n\n参考和后话\n阮一峰的ES6教程\ncodepen 代码验证\n\n本次的ES6语法的汇总总共分为上、中、下三篇，本篇文章为中篇。\n\n谈谈ES6语法（汇总上篇）\n\n文章首发在github上–谈谈ES6语法（汇总中篇）。更多的内容，请戳我的博客进行了解，能留个star就更好了\n","slug":"ES6总结（中）","date":"2023-02-15T03:05:41.000Z","categories_index":"前端,Javascript","tags_index":"ES6,Javascript","author_index":"Abner"},{"id":"94921aa9a74f7374b2a5c0d12ec8143a","title":"ES6总结（下）","content":"本次的ES6语法的汇总总共分为上、中、下三篇，本篇文章为下篇。\n往期系列文章：\n\n谈谈ES6语法（汇总上篇）\n谈谈ES6语法（汇总中篇）\n\n客套话不多说了，直奔下篇的内容～\nasync函数ES2017标准引入了async函数，使得异步操作更加方便。async函数是Generator函数的语法糖。不打算写Generator函数，感兴趣的话可以看文档。与Generator返回值（Iterator对象）不同，async返回的是一个Promise对象。\n用法async函数返回一个Promise对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。\nasync function getStockPriceByName(name) &#123;\n    const symbol = await getStockSymbol(name);\n    const stockPrice = await getStockPrice(symbol);\n    return stockPrice;\n&#125;\ngetStockPriceByName('goog').then(function(result) &#123;\n    console.log(result);\n&#125;)\n\n再来看几种情况加深下印象：\nfunction fun1() &#123;\n  console.log('fun1');\n  return 'fun1 result';\n&#125;\nasync function test() &#123;\n  const result1 = await fun1();\n  console.log(result1);\n  console.log('end');\n&#125;\ntest();\n// 输出 \n// 'fun1'\n// 'fun1 result'\n// 'end'\nasync function fun2() &#123;\n  console.log('fun2');\n  return 'fun2 result';\n&#125;\nasync function test() &#123;\n  const result2 = await fun2();\n  console.log(result2);\n  console.log('end');\n&#125;\ntest();\n// 输出\n// 'fun2'\n// 'fun2 result'\n// 'end'\n\n正常情况下，await命令后面是一个Promise对象，返回该对象的结果。如果不是Promise对象，就直接返回对应的值。\nasync function fun3() &#123;\n  console.log('fun3');\n  setTimeout(function() &#123;\n    console.log('fun3 async');\n    return 'fun3 result';\n  &#125;, 1000)\n&#125;\nasync function test() &#123;\n  const result3 = await fun3();\n  console.log(result3);\n  console.log('end');\n&#125;\ntest();\n// 输出\n// 'fun3'\n// undefined\n// 'end'\n// 'fun3 async'\nasync function fun4() &#123;\n  console.log('fun4');\n  return new Promise((resolve, reject) => &#123;\n    setTimeout(() => &#123;\n      console.log('fun4 async');\n      resolve('fun4 result');\n    &#125;, 1000);\n  &#125;)\n&#125;\nasync function test() &#123;\n  console.log(result4);\n  console.log('fun4 sync');\n  console.log('end');\n&#125;\ntest();\n// 输出\n// 'fun4'\n// 'fun4 async'\n// 'fun4 result'\n// 'fun4 sync'\n// 'end'\n\n模拟sleepJavaScript一直没有休眠的语法，但是借助await命令就可以让程序停顿指定的时间。【await要配合async来实现】\nfunction sleep(interval) &#123;\n    return new Promise(resolve => &#123;\n        setTimeout(resolve, interval);\n    &#125;)\n&#125;\n// use\nasync function one2FiveInAsync() &#123;\n    for(let i = 1; i &lt;= 5; i++) &#123;\n        console.log(i);\n        await sleep(1000);\n    &#125;\n&#125;\none2FiveInAsync();\n// 1, 2, 3, 4, 5 每隔一秒输出数字\n\n一道题需求：使用async await改写下面的代码，使得输出的期望结果是每隔一秒输出0, 1, 2, 3, 4, 5，其中i &lt; 5条件不能变。\nfor(var i &#x3D; 0 ; i &lt; 5; i++)&#123;\n    setTimeout(function()&#123;\n        console.log(i);\n    &#125;,1000)\n&#125;\nconsole.log(i);\n\n之前我们讲过了用promise的方式实现，这次我们用async await方式来实现：\nconst sleep &#x3D; (time) &#x3D;&gt; new Promise((resolve) &#x3D;&gt; &#123;\n    setTimeout(resolve, time);\n&#125;);\n\n(async () &#x3D;&gt; &#123;\n    for(var i &#x3D; 0; i &lt; 5; i++)&#123;\n        console.log(i);\n        await sleep(1000);\n    &#125;\n    console.log(i);\n&#125;)();\n&#x2F;&#x2F; 符合条件的输出 0, 1, 2, 3, 4, 5\n\n比较promise和async为什么只比较promise和async呢？因为这两个用得频繁，实在的才是需要的，而且async语法是generator的语法糖，generator的说法直接戳async与其他异步处理方法的比较。\n两者上，async语法写法上代码量少，错误处理能力佳，而且更有逻辑语义化。\n假定某个 DOM 元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返回值。\n&#x2F;&#x2F; promise\nfunction chainAnimationsPromise(elem, animations) &#123;\n\n  &#x2F;&#x2F; 变量ret用来保存上一个动画的返回值\n  let ret &#x3D; null;\n\n  &#x2F;&#x2F; 新建一个空的Promise\n  let p &#x3D; Promise.resolve();\n\n  &#x2F;&#x2F; 使用then方法，添加所有动画\n  for(let anim of animations) &#123;\n    p &#x3D; p.then(function(val) &#123;\n      ret &#x3D; val;\n      return anim(elem);\n    &#125;);\n  &#125;\n\n  &#x2F;&#x2F; 返回一个部署了错误捕捉机制的Promise\n  return p.catch(function(e) &#123;\n    &#x2F;* 忽略错误，继续执行 *&#x2F;\n  &#125;).then(function() &#123;\n    return ret;\n  &#125;);\n\n&#125;\n&#x2F;&#x2F; async await\nasync function chainAnimationsAsync(elem, animations) &#123;\n  let ret &#x3D; null;\n  try &#123;\n    for(let anim of animations) &#123;\n      ret &#x3D; await anim(elem);\n    &#125;\n  &#125; catch(e) &#123;\n    &#x2F;* 忽略错误，继续执行 *&#x2F;\n  &#125;\n  return ret;\n&#125;\n\n类class在ES6之前，是使用构造函数来模拟类的，现在有了关键字class了，甚是开心\nfunction Person() &#123;&#125;\nPerson.prototype.sayHello &#x3D; function()&#123;\n    console.log(&#39;Hi&#39;);\n&#125;;\nclass Person&#123;\n    sayHello()&#123;\n        console.log(&#39;Hi!&#39;);\n    &#125;\n&#125;\n\nconstructor方法constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法，一个类中必须有construtor方法，如果没有显式定义，一个空的constructor方法会默认添加。\nclass Person&#123;&#125;\n&#x2F;&#x2F; 等同于\nclass Person&#123;\n    constructor()&#123;&#125;\n&#125;\n\nconstrutor方法也就类似构造函数，在执行new的时候，先跑构造函数，再跑到原型对象上。\n取值函数(getter)和存值函数(setter)与ES5一样，在类的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。\nclass MyClass &#123;\n    get prop() &#123;\n        return &#39;getter&#39;;\n    &#125;\n    set prop(value) &#123;\n        console.log(&#96;setter: $&#123; value &#125;&#96;)\n    &#125;\n&#125;\n\nlet inst &#x3D; new MyClass();\n\ninst.prop &#x3D; 123;\n&#x2F;&#x2F; &#39;setter: 123&#39;\n\nconsole.log(inst.prop);\n&#x2F;&#x2F; &#39;getter&#39;\n\nthis的指向类的方法内部如果含有this，它默认是指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。\nclass Person&#123;\n    constructor(job) &#123;\n        this.job &#x3D; job;\n    &#125;\n    printJob() &#123;\n        console.log(&#96;My job is $&#123; this.job &#125;&#96;);\n    &#125;\n  sayHi() &#123;\n    console.log(&#96;I love my job -- $&#123; this.job &#125;.&#96;)\n  &#125;\n&#125;\nconst person &#x3D; new Person(&#39;teacher&#39;);\nperson.printJob(); &#x2F;&#x2F; &#39;My job is teacher&#39;\nconst &#123; sayHi &#125; &#x3D; person;\nsayHi(); &#x2F;&#x2F; 报错: Uncaught TypeError: Cannot read property &#39;job&#39; of undefined\n\n上面的代码中，sayHi方法单独使用，this会指向该方法运行时所在的环境（由于class内部是严格模式，所以this实际上指向undefined）。\n修正上面的错误也很简单，也是我们在react开发中经常使用的一种手段：在调用构造函数实例化的时候直接绑定实例(this)，修改如下：\nclass Person&#123;\n    constructor(job) &#123;\n        this.job &#x3D; job;\n        this.sayHi &#x3D; this.sayHi.bind(this);\n    &#125;\n&#125;\n\n继承ES5中继承的方式我之前有整理过–JavaScript 中的六种继承方式。\nES6中的继承通过extends关键字实现，比ES5的实现继承更加清晰和方便了。\nclass Point &#123;\n  constructor(x, y) &#123;\n    this.x &#x3D; x;\n    this.y &#x3D; y;\n  &#125;\n&#125;\n\nclass ColorPoint extends Point &#123;\n  constructor(x, y, color) &#123;\n    this.color &#x3D; color;\n  &#125;\n&#125;\n\nlet cp &#x3D; new ColorPoint(25, 8, &#39;green&#39;); &#x2F;&#x2F; 报错： Must call super constructor in derived class before accessing &#39;this&#39; or returning from derived constructor\n\n上面这样写，不能继承构造函数里面的属性值和方法。需要在子类的构造函数中加上super关键字。改成下面这样即可：\nclass Point &#123;\n  constructor(x, y) &#123;\n    this.x &#x3D; x;\n    this.y &#x3D; y;\n  &#125;\n&#125;\n\nclass ColorPoint extends Point &#123;\n  constructor(x, y, color) &#123;\n    super(x, y); &#x2F;&#x2F; 调用父类的construtor(x, y)，相当于ES5中的call。注意的是，super要放在子类构造函数的第一行\n    this.color &#x3D; color;\n  &#125;\n&#125;\n\nlet cp &#x3D; new ColorPoint(25, 8, &#39;green&#39;);\n\nmodule模块在ES6之前，社区制定了一些模块的加载的方案，最主要的有CommonJS和AMD两种。前者用于服务器，后者用于浏览器。\n&#x2F;&#x2F; CommonJS\nlet &#123; stat, exists, readFile &#125; &#x3D; require(&#39;fs&#39;);\n\nES6在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS和AMD规范，成为浏览器和服务器通用的模块解决方案。\n&#x2F;&#x2F; ES6模块\nimport &#123; stat, exists, readFile &#125; from &#39;fs&#39;;\n\n各种好处详细见文档\nexport命令export命令用于规定模块的对外接口 。\n一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。你可以理解为一个命名空间～\n想要获取模块里面的变量，你就需要导出export：\n&#x2F;&#x2F; profile.js\nconst name &#x3D; &#39;jia ming&#39;;\nconst sayHi &#x3D; function() &#123;\n    console.log(&#39;Hi!&#39;);\n&#125;\n\nexport &#123; name, sayHi &#125;;\n\n还有一个export default命令，方便用户（开发者啦）不用阅读文档就能加载模块（实际上就是输出一个default变量，而这个变量在import的时候是可以更改的）：\n&#x2F;&#x2F; export-default.js\nexport default function () &#123;\n  console.log(&#39;foo&#39;);\n&#125;\n\n其他模块加载该模块时，import命令可以为该匿名函数指定任意名字。\n&#x2F;&#x2F; import-default.js\nimport customName from &#39;.&#x2F;export-default&#39;;\ncustomName(); &#x2F;&#x2F; &#39;foo&#39;\n\nimport命令import命令用于输入其他模块提供的功能。使用export命令定义了模块的对外接口以后，其他JS文件就可以通过import命令加载这个模块。\n&#x2F;&#x2F; main.js\nimport &#123; name, sayHi &#125; from &#39;.&#x2F;profile.js&#39;;\n\nfunction printName() &#123;\n    console.log(&#39;My name is &#39; + name);\n&#125;\n\n至此，本系列文章谈谈ES6语法已经写完，希望文章对读者有点点帮助。本系列的内容是个人觉得在开发中比较重要的知识点，如果要详细内容的话，请上相关的文档查看～\n参考和后话\n阮一峰的ES6教程\ncodepen 代码验证\n\n本次的ES6语法的汇总总共分为上、中、下三篇，本篇文章为下篇。\n\n谈谈ES6语法（汇总上篇）\n谈谈ES6语法（汇总中篇）\n\n系列文章至此已经完结！\n文章首发在github上–谈谈ES6语法（汇总下篇）。更多的内容，请戳我的博客进行了解，能留个star就更好了\n","slug":"ES6总结（下）","date":"2023-02-15T03:05:41.000Z","categories_index":"前端,Javascript","tags_index":"ES6,Javascript","author_index":"Abner"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new \"My New Post\"\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2023-02-14T07:34:49.275Z","categories_index":"","tags_index":"","author_index":"Abner"}]