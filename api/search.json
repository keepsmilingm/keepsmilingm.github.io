[{"id":"cec6974270c4beff2545a3c7d857d0fa","title":"JS时区转换及常用时间方法","content":"JS 时区转换\n\n\n\n\n\n\n\n\n在开发中时区通常以北京时间为基准，但不排除一些框架或组件默认为其他时区，此时就需要进行时区的转换，例如tdesign中calendar组件时区默认为零时区\n北京时间属于东八区。世界时间总共分为24个时区，分别是东12个时区，西12个时区。每个时区之间相隔一小时。\n方法1// 零区转东八区\nformat(date) &#123;\n    var offset = 8;\n    var targetTime = new Date(date);\n    var utc = targetTime.getTime() + (-28800000);\n    var actualTime = new Date(utc + (3600000 * offset));\n\n    var year = actualTime.getFullYear();\n    var month = (actualTime.getMonth() + 1) > 9 ? (actualTime.getMonth() + 1) : \"0\" + (actualTime.getMonth() +\n        1);\n    var day = actualTime.getDate() > 9 ? actualTime.getDate() : \"0\" + actualTime.getDate();\n    var hour = actualTime.getHours() > 9 ? actualTime.getHours() : \"0\" + actualTime.getHours();\n    var minute = actualTime.getMinutes() > 9 ? actualTime.getMinutes() : \"0\" + actualTime.getMinutes();\n    var second = actualTime.getSeconds() > 9 ? actualTime.getSeconds() : \"0\" + actualTime.getSeconds();\n    return year + \"-\" + month + \"-\" + day + \" \" + hour + \":\" + minute + \":\" + second;\n&#125;,\n\n方法2let utcDate = new Date(\"2023-07-31T02:36:31.000+00:00\");\nlet chinaTime = utcDate.toLocaleString(\"en-US\", &#123;timeZone: \"Asia/Shanghai\", hour12: false&#125;);\n\n// 把日期和时间格式化成 'yyyy-mm-dd hh:mm:ss' 格式\nchinaTime = chinaTime.replace(/\\/|,|:/g, \"-\").split(\"-\");\nchinaTime = `$&#123;chinaTime[2]&#125;-$&#123;chinaTime[0].padStart(2, '0')&#125;-$&#123;chinaTime[1].padStart(2, '0')&#125; $&#123;chinaTime[3]&#125;:$&#123;chinaTime[4]&#125;:$&#123;chinaTime[5]&#125;`;\n\nconsole.log(chinaTime);  // 输出：'2023-07-31 10:36:31'\n\n时间常用方法\n获取完整的年份(4位,2019)： myDate.getFullYear()\n获取当前月份(0-11,0代表1月)： myDate.getMonth()\n获取当前日(1-31)： myDate.getDate()\n获取当前星期X(0-6,0代表星期天)： myDate.getDay()\n获取当前时间(从1970.1.1开始的毫秒数)： myDate.getTime()\n获取当前小时数(0-23)： myDate.getHours()\n获取当前分钟数(0-59)： myDate.getMinutes()\n获取当前秒数(0-59)： myDate.getSeconds()\n获取当前毫秒数(0-999)： myDate.getMilliseconds()\n获取当前日期： myDate.toLocaleDateString()\n获取当前时间： myDate.toLocaleTimeString()\n获取日期与时间： myDate.toLocaleString()\n\n时间计算","slug":"JS 时区转换","date":"2023-03-10T06:35:07.000Z","categories_index":"js","tags_index":"js","author_index":"Abner"},{"id":"36a6e58ce41424b667a06f36b106db92","title":"JS中各种循环及其终止方式","content":"一、for循环终止for循环的方式：break和continuebreak：整个循环结束 continue：退出本次循环\nlet list = [1, 2, 3, 4]\nfor (let i = 0; i &lt; list.length; i++) &#123;\n  if (i == 1) &#123;\n    continue\n  &#125;\n  if (i == 2) &#123; \n    break;\n  &#125;\n&#125;\n\n二、forEach循环用return、break、continue的方式都不能终止forEach循环，return在forEach里相当于for循环里的continue，能够退出本次循环，可以使用try...chtch终止foreach循环\ntry&#123;\n  var array = [\"first\",\"second\",\"third\",\"fourth\"];\n  // 执行到第3次,结束循环\n  array.forEach(function(item,index) &#123;\n    if(item == \"third\")&#123;\n      throw new Error(\"EndIterative\");\n    &#125;\n    console.log(item); // first second\n  &#125;);\n&#125;catch(e)&#123;\n  if(e.message != \"EndIterative\") throw e;\n&#125;\n// 下面的代码不影响继续执行\nconsole.log(\"继续执行。。。\");\n\n二、map循环终止map循环的方式和forEach相同\nlet list = [1, 2, 3, 4]\ntry &#123;\n  list.map(item => &#123;\n    console.log('执行');\n    if (item == 1) &#123;\n      throw new Error('stop')\n    &#125;\n  &#125;)\n&#125; catch (e) &#123;\n  if (e.message !== 'stop') &#123;\n    throw e\n  &#125;\n&#125;\n\n三，for in 循环for…in循环主要是为了遍历对象的，break或continue可以生效\nconst person = &#123;\n  name: \"111\",\n  age: 18,\n  1: 1,\n  job: \"student\",\n&#125;;\n\nfor (const key in person) &#123;\n  if (key === \"age\") &#123;\n    break;\n  &#125;\n  if (key === 'name') &#123;\n    continue;\n  &#125;\n&#125;\n\n四，for of 循环for…of和for…in都能用break和continue结束(跳出当前)循环\n我们都知道for…of只能用来遍历那些内置iterator（Array, Atring, ArrayLike, Set, Map…）或者实现了iterator方法的数据类型，而普通的Object并没有内置iterator\nfor (const val of arr) &#123;\n  if (val === 2) &#123;\n    continue;\n  &#125;\n  if (val === 3) &#123;\n    break;\n  &#125;\n&#125;\n\n五，every()和some()every()：相当于且，只要有一个不满足条件，就return false，只有都满足条件才会返回true\nsome()：相当于或，只要有一个满足条件，就return true\nlet list = [\n  &#123; name:\"aaa\", age:3 &#125;,\n  &#123; name:\"bbb\", age:4 &#125;,\n  &#123; name:\"ccc\", age:5 &#125;,\n]\n\nvar every = list.every(function (item) &#123;\n  return item.age > 4\n&#125;)\nconsole.log(every ) // false\n\nvar some = list.some(function (item) &#123;\n  return item.age > 4\n&#125;)\nconsole.log(some) // true\n\n\n\n\n\n\n\n\n\n\nsome退出循环：return &#x2F; return true， every退出循环：return false\n","slug":"JS循环及终止方式","date":"2023-03-10T06:35:07.000Z","categories_index":"js","tags_index":"js,es6","author_index":"Abner"},{"id":"8e824aa52ddbbaf8c82d0cbfb5a84f60","title":"keep-alive的使用","content":"应用场景1、vue工程，很多时候希望页面不管怎么跳转，返回时候，页面都能保持之前的操作状态，\n2、页面跳转不用每次都执行mounted，特别很多请求数据时候，都是从mounted发起，不需要每次跳转都执行一次请求数据。\n这就需要使用vue的keep-alive缓存。\n解决思路一、缓存所有页面如果需要缓存所有页面，就在使用router-view中地方（一般都是app.vue,但也不绝对是，就是控制要缓存的页面router跳转的上一级直接router-view的地方）外围包上标签\n&lt;template>\n      &lt;div id=\"app\">\n        &lt;keep-alive >\n          &lt;router-view>&lt;/router-view>\n        &lt;/keep-alive>\n      &lt;/div>\n &lt;/template>\n\n二、缓存部分页面缓存部分页面，一般有两种方式：\n（1）使用router.meta属性\nrouter-view文件中：（app.vue）\n&lt;template>\n      &lt;div id=\"app\">\n        &lt;keep-alive >\n          &lt;router-view v-if=\"$route.meta.keepAlive\">&lt;/router-view>   //放需要缓存的组件\n        &lt;/keep-alive>\n        &lt;router-view v-if=\"!$route.meta.keepAlive\">&lt;/router-view>  //放不需要缓存的组件\n      &lt;/div>\n    &lt;/template>\n\n路由配置文件router.js文件中，给需要缓存的路由加上meta属性，并设置值。\n&#123;\n      path: '/usermanage',\n      name: 'usermanage',\n      meta: &#123;\n        keepAlive: true, //该字段表示该页面需要缓存\n      &#125;,\n      component: resolve => require(['@/views/userManage/userManage'], resolve) // 路由懒加载\n    &#125;,\n\n（2）使用vue-router 2.X的include、exclude两个属性，针对性的缓存相应的组件\ninclude属性表示只有name属性为a，b的组件会被缓存，（注意是组件的名字，不是路由的名字）其它组件不会被缓存exclude属性表示除了name属性为a,b的组件不会被缓存，其它组件都会被缓存\n在使用router-view标签的vue文件中修改：\n&lt;keep-alive include=\"a,b\">\n   &lt;router-view>&lt;/router-view>\n&lt;/keep-alive>\n\n注意：上面代码中的a，b是需要缓存的组件中的的name值（a.vue中的name值），不是路由的name值。\n三、页面缓存了，有的功能需要再进入后，仍然重新执行的怎么办当引入keep-alive的时候，页面第一次进入，钩子的触发顺序created-&gt; mounted-&gt; activated，退出时触发deactivated。当再次进入（前进或者后退）时，只触发activated。\n事件挂载的方法等，只执行一次的放在 mounted 中；组件每次进去执行的方法放在 activated 中， activated 中的不管是否需要缓存多会执行。\n注意：当组件在  内被切换时，它的 activated 和 deactivated 这两个生命周期钩子函数将会被对应执行。\nactivated：进入页面时候执行\nactivated()&#123;&#125;,\n\ndeactivated：退出页面时候执行\ndeactivated()&#123;&#125;,\n\n四、执行前进刷新，后退时候缓存参照五、需要在加一个变量，确定从哪里到哪里是前进，从哪里到哪里是后退\n（1）router.js中，A的路由设置\n&#123;\n      path: '/usermanage',\n      name: 'usermanage',\n      meta: &#123;\n        keepAlive: true, //该字段表示该页面需要缓存\n        isBack: false, //用于判断上一个页面是哪个\n        title: '人员管理'\n      &#125;,\n      component: resolve => require(['@/views/userManage/userManage'], resolve) // 路由懒加载\n    &#125;,\n\n（2）其他页面中，，利用路由钩子函数，修改isback这个值，\n五、页面B进入页面A需要缓存，页面C进入页面A不需要缓存思路：在每个路由的路由钩子函数beforeRouteLeave(to, from, next)钩子中设置 to.meta.keepAlive的true或者false值。\n具体流程：\n（1）router.js中，A的路由设置：\n&#123;\n    path: '/',\n    name: 'A',\n    component: A,\n    meta: &#123;\n        keepAlive: true // 需要被缓存\n    &#125;\n&#125;\n\n（2）C.vue文件中：\nexport default &#123;\n    data() &#123;\n        return &#123;&#125;;\n    &#125;,\n    methods: &#123;&#125;,\n    beforeRouteLeave(to, from, next) &#123;\n        // 设置下一个路由的 meta\n        if(from.name==\"C的路由名字\")&#123;\n            to.meta.keepAlive = false; // C 跳转到 A 时让 A 不缓存，即刷新，to表示要跳转的A\n        &#125;\n        next();\n    &#125;\n&#125;;\n\n（3）B.vue\nexport default &#123;\n    data() &#123;\n        return &#123;&#125;;\n    &#125;,\n    methods: &#123;&#125;,\n    beforeRouteLeave(to, from, next) &#123;\n        // 设置下一个路由的 meta\n        if(from.name==\"B的路由名字\")&#123;\n            to.meta.keepAlive = true; // C 跳转到 A 时让 A 不缓存，即刷新，to表示要跳转的A\n        &#125;\n        next();\n    &#125;\n&#125;;\n","slug":"keep-alive的使用","date":"2023-03-10T06:35:07.000Z","categories_index":"Vue","tags_index":"Vue,缓存","author_index":"Abner"},{"id":"a86028911b6e2a12ef38fa51903065cc","title":"React杂记（持续更新中）","content":"ReactjsxSTATEHooks ——以 use 开头的函数——只能在组件或自定义 Hook 的最顶层调用。 你不能在条件语句、循环语句或其他嵌套函数内调用 Hook。Hook 是函数，但将它们视为关于组件需求的无条件声明会很有帮助。在组件顶部 “use” React 特性，类似于在文件顶部“导入”模块。\n\n设置 state 请求一次新的渲染。\n\nReact 将 state 存储在组件之外，就像在架子上一样。\n\n当你调用 useState 时，React 会为你提供该次渲染 的一张 state 快照。\n\n变量和事件处理函数不会在重渲染中“存活”。每个渲染都有自己的事件处理函数。\n\n每个渲染（以及其中的函数）始终“看到”的是 React 提供给这个 渲染的 state 快照。\n\n你可以在心中替换事件处理函数中的 state，类似于替换渲染的 JSX。\n\n过去创建的事件处理函数拥有的是创建它们的那次渲染中的 state 值。\n\nReact 会使 state 的值始终”固定“在一次渲染的各个事件处理函数内部。 你无需担心代码运行时 state 是否发生了变化。\n\n一个 state 变量的值永远不会在一次渲染的内部发生变化， 即使其事件处理函数的代码是异步的\nfunction handleSubmit() &#123;\n value++\n setTimeout(() => &#123;\n alert(value);\n &#125;, 5000);\n&#125;\n/** value值即使在定时器时限内被改变，定时器结束后`alert`出的还是第一次\n触发handleSubmit时的值，如下拉选择，连续切换两次，第一个alert出的还是第\n一次切换时的值**/\n\nReact 会等到事件处理函数中的所有代码都运行完毕再处理你的 state 更新。\nconst [number, setNumber] = useState(0);\n\nfunction ()&#123;\n  setNumber(number+ 1);\n  setNumber(number + 1);\n  setNumber(number+ 1);\n&#125;\n// 最后得到的number的值还是1，并不是3,因为函数未执行完毕，number的值未更新\n\n在下次渲染前多次更新同一个 state（批处理）const [number, setNumber] = useState(0);\n\nfunction ()&#123;\n   setNumber(n => n + 1);\n   setNumber(n => n + 1);\n   setNumber(n => n + 1);\n&#125;\n\n组件生命周期组件的生命周期包含三个主要部分：\n\n挂载： 组件被插入到DOM中。\n更新： 组件被重新渲染，查明DOM是否应该刷新。\n移除： 组件从DOM中移除。\n\nReact提供生命周期方法，你可以在这些方法中放入自己的代码。我们提供will方法，会在某些行为发生之前调用，和did方法，会在某些行为发生之后调用。\n挂载\ngetInitialState(): object在组件被挂载之前调用。状态化的组件应该实现这个方法，返回初始的state数据。\ncomponentWillMount()在挂载发生之前立即被调用。\ncomponentDidMount()在挂载结束之后马上被调用。需要DOM节点的初始化操作应该放在这里。\n\n更新\ncomponentWillReceiveProps(object nextProps)当一个挂载的组件接收到新的props的时候被调用。该方法应该用于比较this.props和nextProps，然后使用this.setState()来改变state。\nshouldComponentUpdate(object nextProps, object nextState): boolean当组件做出是否要更新DOM的决定的时候被调用。实现该函数，优化this.props和nextProps，以及this.state和nextState的比较，如果不需要React更新DOM，则返回false。\ncomponentWillUpdate(object nextProps, object nextState)在更新发生之前被调用。你可以在这里调用this.setState()。\ncomponentDidUpdate(object prevProps, object prevState)在更新发生之后调用。\n\n移除\ncomponentWillUnmount()在组件移除和销毁之前被调用。清理工作应该放在这里。\n\n挂载的方法（Mounted Methods）_挂载的_复合组件也支持如下方法：\n\ngetDOMNode(): DOMElement可以在任何挂载的组件上面调用，用于获取一个指向它的渲染DOM节点的引用。\nforceUpdate()当你知道一些很深的组件state已经改变了的时候，可以在该组件上面调用，而不是使用this.setState()。\n\ngetinitialstate\ncomponentwillmount\ncomponentDidMount\ncomponentWillReceiveProps\nshouldComponentUpdate\ncomponentWillUpdate\ncomponentDidUpdate\ncomponentWillUnMount\nuseEffectuseEffect的含义：副作用钩子，用于处理组件中的副作用，用来取代生命周期函数。所谓的”副作用”就是指的是组件中状态或生命周期改变时在useEffect可监听到。\n如果熟悉class组件中生命周期方法，可以将useEffect视作coponentDidMount、componentDidUpdate和componentWillUnmount的组合体。\nuseEffect使用的几种方式，根据第二个参数的情况而定\n\n无此参数：组件的任何更新，该 useEffect 对应的返回函数和函数都执行\n为空数组：只在componentDidMount执行一次，不监听组件的更新，\n数组中有具体依赖：对应的依赖数据，有变化的时候，才会执行（初始不会执行）\n\n清除 effect通常，组件卸载时需要清除 effect 创建的诸如订阅或计时器 ID 等资源。要实现这一点，useEffect 函数需返回一个清除函数。以下就是一个事件绑定的例子：\nimport &#123; useState, useEffect &#125; from \"react\";\nimport * as ReactDOM from \"react-dom\";\n\nfunction App() &#123;\n  const [position, setPosition] = useState(&#123;x:0, y: 0&#125;)\n\n  useEffect(()=>&#123;\n    console.log('点击了b')\n    const mouseClickHandle = (e) =>&#123;\n      console.log('点击了c')\n      setPosition(&#123;\n        x: e.clientX,\n        y: e.clientY\n      &#125;)\n    &#125;\n    document.addEventListener('click', mouseClickHandle)\n\n    // return ()=>&#123;\n    //   console.log('点击了d')\n    //   document.removeEventListener('click', mouseClickHandle)\n    // &#125;\n  &#125;)\n  console.log('点击了a')\n\n  return (\n    &lt;>\n      &lt;p>\n        X：&#123;position.x&#125;, Y: &#123;position.y&#125;\n      &lt;/p>\n    &lt;/>\n  )\n&#125;\n\nconst rootElement = document.getElementById(\"root\");\nReactDOM.render(&lt;App />, rootElement);\n\n执行点击事件，可以看到打印结果如下：\n\n微信截图_20211207151814.png\n可以看到，当我第三次点击的时候，打印结果显示click事件被执行了两次，在这个示例中，意味着组件的每一次更新都会创建新的事件绑定，这很显然是不被允许的。这个时候就需要使用清除函数，清除函数会在组件卸载前执行。另外，如果组件多次渲染（通常如此），则在执行下一个 effect 之前，上一个 effect 就已被清除。\nuseEffect允许返回一个函数来解决上述问题：\nuseEffect(()=>&#123;\n   console.log('点击了b')\n   const mouseClickHandle = (e) =>&#123;\n     console.log('点击了c')\n     setPosition(&#123;\n       x: e.clientX,\n       y: e.clientY\n     &#125;)\n   &#125;\n   document.addEventListener('click', mouseClickHandle)\n   // 在此处返回一个解绑函数即可\n   return ()=>&#123;\n     console.log('点击了d')\n     document.removeEventListener('click', mouseClickHandle)\n   &#125;\n&#125;)\nconsole.log('点击了a')\n\n当返回一个解绑函数后再次测试发现，在组件在执行下一个 effect 之前，上一个 effect 就已被清除（d在b之前打印可以印证这点）。\n\n微信截图_20211207152514.png\n下面再来印证上述提到的第二个参数为空数组的情况：\nuseEffect(()=>&#123;\n   console.log('点击了b')\n   const mouseClickHandle = (e) =>&#123;\n     console.log('点击了c')\n     setPosition(&#123;\n       x: e.clientX,\n       y: e.clientY\n     &#125;)\n   &#125;\n   document.addEventListener('click', mouseClickHandle)\n\n   return ()=>&#123;\n     console.log('点击了d')\n     document.removeEventListener('click', mouseClickHandle)\n   &#125;\n &#125;,[])\n console.log('点击了a')\n\n\n可以看到，当第二个参数为空数组的时候，b和d都没有打印，说明此时useEffect并不被执行，执行的只是初始进入就绑定的事件。\n","slug":"React","date":"2023-03-10T06:35:07.000Z","categories_index":"React","tags_index":"React","author_index":"Abner"},{"id":"3544a0d90b0e0c3822563e88d582f926","title":"微信小程序:app.js及index.js详解","content":"1、app.js这是小程序的入口，启动小程序时首先调用app.js。\nApp()注册小程序，然后内部按生命周期执行。\n//app.js//注册小程序App(&#123;   onLaunch: function () &#123;     console.log(\"app.js初始化\")    // 展示本地存储能力    // 往本地存储写入log数据，登录日志    var logs = wx.getStorageSync('logs') || []    logs.unshift(Date.now())    wx.setStorageSync('logs', logs)    // 登录    // 用户登录小程序    wx.login(&#123;       success: res => &#123;         // 登录成功后的回调        // 发送 res.code 到后台换取 openId, sessionKey, unionId        console.log('wx.login登录成功')      &#125;    &#125;)    // 重点在这    // 获取用户的设置，返回用户的授权信息    // 判断用户是否授权，若已经授权，调用wx.getUserInfo接口获取用户信息，    // 将获取的信息存到全局状态this.globalData.userInfo    // 若用户未授权，直接逃过，进入index页面    wx.getSetting(&#123;       success: res => &#123;         // 获取成功的回调        console.log('获取用户的当前设置,返回授权后的信息')        console.log(res)        //判断用户是否授权        if (res.authSetting['scope.userInfo']) &#123;           // 已经授权，则无需重复授权          // 可以直接调用 wx.getUserInfo 获取用户信息，不会弹框          console.log(\"用户已经授权\")          wx.getUserInfo(&#123;             success: res => &#123;               // 获取用户信息成功后的回调              // 可以将 res 发送给后台解码出 unionId              // 将用户信息赋值给this.globalData.userInfo              this.globalData.userInfo = res.userInfo              console.log('app.js中获取用户信息成功')              console.log(this.globalData.userInfo)              // 由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回              // 所以此处加入 callback 以防止这种情况              // app.userInfoReadyCallback是在index的onLoad函数中定义的              // 判断userInfoReadyCallback这个属性是否存在              // 如果存在，则执行，将用户数据赋值给globalData及index中的data              if (this.userInfoReadyCallback) &#123;                 this.userInfoReadyCallback(res)              &#125;            &#125;          &#125;)        &#125;      &#125;    &#125;)  &#125;,  // 全局状态  globalData: &#123;     userInfo: null  &#125;&#125;)\n\n（1）在onLoad函数中，首先将小程序的登录日志写入到本地。\n每加载一次小程序，就写入一次。\n// 展示本地存储能力    // 往本地存储写入log数据，登录日志    var logs = wx.getStorageSync('logs') || []    logs.unshift(Date.now())    wx.setStorageSync('logs', logs)\n\n（2）小程序登录。\n调用wx.login接口，换取 openId, sessionKey, unionId\n有后端API才有用，这里没有后端，所以只打印了一下\n&#x2F;&#x2F; 登录    &#x2F;&#x2F; 用户登录小程序    wx.login(&#123;       success: res &#x3D;&gt; &#123;         &#x2F;&#x2F; 登录成功后的回调        &#x2F;&#x2F; 发送 res.code 到后台换取 openId, sessionKey, unionId        console.log(&#39;wx.login登录成功&#39;)      &#125;    &#125;)\n\n（3）读取用户信息。\nwx.getSetting()获取用户设置（返回用户的已授权信息）\n若已授权（res.authSetting[‘scope.userInfo’]存在），通过wx.getUserInfo调用用户信息。调用成功后，写入全局状态this.globalData.userInfo，然后index页面中通过onLoad函数调用globalData.userInfo，在index页面显示用户信息。\n&#x2F;&#x2F; 重点在这    &#x2F;&#x2F; 获取用户的设置，返回用户的已授权信息    &#x2F;&#x2F; 判断用户是否授权，若已经授权，调用wx.getUserInfo接口获取用户信息，    &#x2F;&#x2F; 将获取的信息存到全局状态this.globalData.userInfo    &#x2F;&#x2F; 若用户未授权，直接逃过，进入index页面    wx.getSetting(&#123;       success: res &#x3D;&gt; &#123;         &#x2F;&#x2F; 获取成功的回调        console.log(&#39;获取用户的当前设置,返回授权后的信息&#39;)        console.log(res)        &#x2F;&#x2F;判断用户是否授权        if (res.authSetting[&#39;scope.userInfo&#39;]) &#123;           &#x2F;&#x2F; 已经授权，则无需重复授权          &#x2F;&#x2F; 可以直接调用 wx.getUserInfo 获取用户信息，不会弹框          console.log(&quot;用户已经授权&quot;)          wx.getUserInfo(&#123;             success: res &#x3D;&gt; &#123;               &#x2F;&#x2F; 获取用户信息成功后的回调              &#x2F;&#x2F; 可以将 res 发送给后台解码出 unionId              &#x2F;&#x2F; 将用户信息赋值给this.globalData.userInfo              this.globalData.userInfo &#x3D; res.userInfo              console.log(&#39;app.js中获取用户信息成功&#39;)              console.log(this.globalData.userInfo)              &#x2F;&#x2F; 由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回              &#x2F;&#x2F; 所以此处加入 callback 以防止这种情况              &#x2F;&#x2F; app.userInfoReadyCallback是在index的onLoad函数中定义的              &#x2F;&#x2F; 判断userInfoReadyCallback这个属性是否存在              &#x2F;&#x2F; 如果存在，则执行，将用户数据赋值给globalData及index中的data              if (this.userInfoReadyCallback) &#123;                 this.userInfoReadyCallback(res)              &#125;            &#125;          &#125;)        &#125;      &#125;    &#125;)  &#125;,\n\n但这里有一个问题，如果index页面加载完了，wx.getUserInfo才返回数据怎么办？\n因为wx.getUserInfo是通过网络异步获取用户数据，无法保证一定在index页面加载之前就能获取到啊。\n这里就用了userInfoReadyCallback函数，这个函数是在index的onLoad函数定义的。\napp.userInfoReadyCallback &#x3D; res &#x3D;&gt; &#123;         this.setData(&#123;           userInfo: res.userInfo,          hasUserInfo: true        &#125;)      &#125;\n\n就是一个简单的赋值函数，将res赋值给index中的data。\n而在app.js中的wx.getUserInfo中判断app.userInfoReadyCallback是否存在，如果存在，那么就说明index中的onload函数已经为app写入了userInfoReadyCallback方法，也就是说wx.getUserInfo是通过网络异步获取用户数据成功，实在index加载数据之后，这时就需要调用这个方法，将wx.getUserInfo的返回信息，写入到index中的data。**\n2、index.js&#x2F;&#x2F; index.js&#x2F;&#x2F; 获取应用实例&#x2F;&#x2F; 用于调用全局状态app.globalDataconst app &#x3D; getApp()&#x2F;&#x2F; 注册当前页面indexPage(&#123;   data: &#123;     motto: &#39;Hello &#39;,    userInfo: &#123; &#125;,    hasUserInfo: false,    &#x2F;&#x2F; 用于判断微信是否支持button.open-type.getUserInfo用法    canIUse: wx.canIUse(&#39;button.open-type.getUserInfo&#39;)  &#125;,  &#x2F;&#x2F; 生命周期函数，页面加载时  onLoad: function () &#123;     console.log(&#39;index.js初始化&#39;)    &#x2F;&#x2F; 判断是否已经获取到用户信息    if (app.globalData.userInfo) &#123;       &#x2F;&#x2F; 已经获取用户信息      &#x2F;&#x2F; 将用户信息赋值给userInfo      &#x2F;&#x2F; 将hasUserInfo设置为true      this.setData(&#123;         userInfo: app.globalData.userInfo,        hasUserInfo: true      &#125;)      console.log(&quot;写入data数据成功&quot;)      this.routerGo()    &#125; else if (this.data.canIUse)&#123;       &#x2F;&#x2F; 未获取到用户信息，但微信支持button.open-type.getUserInfo用法      &#x2F;&#x2F; 定义app.userInfoReadyCallback函数，      &#x2F;&#x2F; 这个函数在app.js调用      &#x2F;&#x2F; 由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回      &#x2F;&#x2F; 所以此处加入 callback 以防止这种情况      app.userInfoReadyCallback &#x3D; res &#x3D;&gt; &#123;         this.setData(&#123;           userInfo: res.userInfo,          hasUserInfo: true        &#125;)      &#125;    &#125; else &#123;       &#x2F;&#x2F; 微信不支持button.open-type.getUserInfo用法      &#x2F;&#x2F; 在没有 open-type&#x3D;getUserInfo 版本的兼容处理      wx.getUserInfo(&#123;         success: res &#x3D;&gt; &#123;           app.globalData.userInfo &#x3D; res.userInfo          this.setData(&#123;             userInfo: res.userInfo,            hasUserInfo: true          &#125;)        &#125;      &#125;)    &#125;  &#125;,  &#x2F;&#x2F; 绑定自定义点击事件getUserInfo  &#x2F;&#x2F; 获取用户信息  &#x2F;&#x2F; 回调函数，e就是用户授权后的返回值  &#x2F;&#x2F; 若用户授权，用户信息保存在e.detail.userInfo  &#x2F;&#x2F; 若用户拒绝，e.detail.userInfo为undefined  getUserInfo: function(e) &#123;     console.log(&quot;index按钮点击了，调用用户信息&quot;)    console.log(e)    console.log(e.detail.userInfo)    &#x2F;&#x2F; 将用户信息    app.globalData.userInfo &#x3D; e.detail.userInfo    this.setData(&#123;       userInfo: e.detail.userInfo,      hasUserInfo: true    &#125;)    this.routerGo()  &#125;,   &#x2F;&#x2F; 事件处理函数  bindViewTap: function() &#123;     wx.navigateTo(&#123;       url: &#39;..&#x2F;logs&#x2F;logs&#39;    &#125;)  &#125;,  &#x2F;&#x2F; 实现页面自动跳转  routerGo()&#123;     console.log(&#39;跳转函数调用了&#39;)    &#x2F;&#x2F; 定义一个周期函数interval    &#x2F;&#x2F; 判断image图片是否渲染，渲染成功后自动跳转    let interval&#x3D;setInterval( ()&#x3D;&gt; &#123;       if (wx.createSelectorQuery().select(&#39;image&#39;)) &#123;         console.log(wx.createSelectorQuery().select(&#39;image&#39;))        &#x2F;&#x2F; 跳转        &#x2F;&#x2F; 跳转成功后执行回调函数clearInterval        wx.navigateTo(&#123;           url: &#39;.&#x2F;..&#x2F;lession&#x2F;lession&#39;,          success:()&#x3D;&gt;&#123;             console.log(this)            clearInterval(interval)          &#125;,        &#125;)      &#125;    &#125;, 500)   &#125;&#125;)\n\n（1）获取全局应用app\n这样可以通过app.globalData.userInfo获取全局状态。\n&#x2F;&#x2F; index.js&#x2F;&#x2F; 获取应用实例&#x2F;&#x2F; 用于调用全局状态app.globalDataconst app &#x3D; getApp()\n\n（2）通过Page（）注册当前页面。\n（3）其中data是index页面的数据\ndata: &#123;     motto: 'Hello ',    userInfo: &#123; &#125;,    hasUserInfo: false,    // 用于判断微信是否支持button.open-type.getUserInfo用法    canIUse: wx.canIUse('button.open-type.getUserInfo')  &#125;,\n\n（4）然后执行onLoad生命周期函数。\n 看着复制，其实逻辑很简单。\n条件一：判断app.globalData.userInfo中有信息，写入data。this.routerGo()是我自己写的页面跳转函数，自动跳转到下一个页面。可忽略。\n条件二：判断app.globalData.userInfo中没有信息&amp;&amp;微信版本支持button.open-type.getUserInfo（this.data.canIUse）获取用户信息的方式，那么就是说wx.getUserInfo是网络请求，可能会在 Page.onLoad 之后才返回，所以定义app.userInfoReadyCallback方法，在wx.getUserInfo的成功回调中执行。\n条件三：判断app.globalData.userInfo中没有信息&amp;&amp;微信版本不支持，那么直接调用wx.getUserInfo（）接口。\nonLoad函数执行完毕。\n&#x2F;&#x2F; 生命周期函数，页面加载时  onLoad: function () &#123;     console.log(&#39;index.js初始化&#39;)    &#x2F;&#x2F; 判断是否已经获取到用户信息    if (app.globalData.userInfo) &#123;       &#x2F;&#x2F; 已经获取用户信息      &#x2F;&#x2F; 将用户信息赋值给userInfo      &#x2F;&#x2F; 将hasUserInfo设置为true      this.setData(&#123;         userInfo: app.globalData.userInfo,        hasUserInfo: true      &#125;)      console.log(&quot;写入data数据成功&quot;)      this.routerGo()    &#125; else if (this.data.canIUse)&#123;       &#x2F;&#x2F; 未获取到用户信息，但微信支持button.open-type.getUserInfo用法      &#x2F;&#x2F; 定义app.userInfoReadyCallback函数，      &#x2F;&#x2F; 这个函数在app.js调用      &#x2F;&#x2F; 由于 wx.getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回      &#x2F;&#x2F; 所以此处加入 callback 以防止这种情况      app.userInfoReadyCallback &#x3D; res &#x3D;&gt; &#123;         this.setData(&#123;           userInfo: res.userInfo,          hasUserInfo: true        &#125;)      &#125;    &#125; else &#123;       &#x2F;&#x2F; 微信不支持button.open-type.getUserInfo用法      &#x2F;&#x2F; 在没有 open-type&#x3D;getUserInfo 版本的兼容处理      wx.getUserInfo(&#123;         success: res &#x3D;&gt; &#123;           app.globalData.userInfo &#x3D; res.userInfo          this.setData(&#123;             userInfo: res.userInfo,            hasUserInfo: true          &#125;)        &#125;      &#125;)    &#125;  &#125;,\n\n（5）绑定捕获事件。\n&#x2F;&#x2F; 事件处理函数  bindViewTap: function() &#123;     wx.navigateTo(&#123;       url: &#39;..&#x2F;logs&#x2F;logs&#39;    &#125;)  &#125;,  &#x2F;&#x2F; 绑定自定义点击事件getUserInfo  &#x2F;&#x2F; 获取用户信息  &#x2F;&#x2F; 回调函数，e就是用户授权后的返回值  &#x2F;&#x2F; 若用户授权，用户信息保存在e.detail.userInfo  &#x2F;&#x2F; 若用户拒绝，e.detail.userInfo为undefined  getUserInfo: function(e) &#123;     console.log(&quot;index按钮点击了，调用用户信息&quot;)    console.log(e)    console.log(e.detail.userInfo)    &#x2F;&#x2F; 将用户信息    app.globalData.userInfo &#x3D; e.detail.userInfo    this.setData(&#123;       userInfo: e.detail.userInfo,      hasUserInfo: true    &#125;)    this.routerGo()  &#125;,\n\n（6）自定义方法，实现页面跳转。\nrouterGo()&#123;     console.log(&#39;跳转函数调用了&#39;)    &#x2F;&#x2F; 定义一个周期函数interval    &#x2F;&#x2F; 判断image图片是否渲染，渲染成功后自动跳转    let interval&#x3D;setInterval( ()&#x3D;&gt; &#123;       if (wx.createSelectorQuery().select(&#39;image&#39;)) &#123;         console.log(wx.createSelectorQuery().select(&#39;image&#39;))        &#x2F;&#x2F; 跳转        &#x2F;&#x2F; 跳转成功后执行回调函数clearInterval        wx.navigateTo(&#123;           url: &#39;.&#x2F;..&#x2F;lession&#x2F;lession&#39;,          success:()&#x3D;&gt;&#123;             console.log(this)            clearInterval(interval)          &#125;,        &#125;)      &#125;    &#125;, 500)   &#125;\n","slug":"微信小程序学习：（二）app.js及index.js详解","date":"2023-03-10T06:35:07.000Z","categories_index":"Vue","tags_index":"Vue,缓存","author_index":"Abner"},{"id":"f89b169e24befa8d039f567cb8fa2f63","title":"window.showModalDialog的替代方案","content":"window.showModalDialog的替代方法window.showModalDialog使用说明\n\n\n\n\n\n\n\n\n该方法用于弹出弹框或新窗口，可拿到弹框返回值，是阻断性的方法子窗体通过window.returnValue&#x3D;””来传值\n替代方法 window.open\n\n\n\n\n\n\n\n\n该方法同样用于弹出弹框或新窗，非阻断性方法，故无法同步拿到返回值子窗体通过window.opener.window.returnValue&#x3D;””来传值\nwindow.showModalDialog与window.open的异同点1、showModalDialog() 弹出一个对话框，对话框是依附于打开它的那个窗口的；window.open() 是开一个新窗口，和打开它的那个窗口是独立的 showModalDialog() 必须关闭才能操作打开它的那个窗口；而 window.open() 打开的窗口不必关闭也可以操作打开它的那个窗口 二者控制打开它的窗口方法也不一样，一个使用 dialogArguments，后者使用 opener\n完善替代方案\n\n\n\n\n\n\n\n\n使用window.open结合定时器的方法，在子窗口关闭后返回数据，并实现阻断\n父页面function openNewWindow(url, target, features, callback) &#123;\n\tlet wd;\n\tlet winTimer;//计时器变量, 监听窗口关闭\n\tif (!features) &#123;\n\t\tfeatures = \"dialogWidth=800px, dialogHeight=600px, dialogTop=200px, dialogLeft=400px, toolbar=no, menubar=no,scrollbars=yes, resizable=yes,location=no, status=no\";\n\t&#125;\n\tlet opts = features.replace(/:/g, '=')\n\t\t.replace(/;/g, ',')\n\t\t.replace('dialogWidth', 'width')\n\t\t.replace('dialogHeight', 'height')\n\t\t.replace('dialogTop', 'top')\n\t\t.replace('dialogLeft', 'left')\n\t\t.replace('scroll', 'scrollbars');\n\twd = window.open(url, target, opts);\n\n\twinTimer = window.setInterval(function windowClosed() &#123;\n\t\tif (wd.closed) &#123;\n\t\t\t// alert(window.returnValue);//子窗体返回\n\t\t\t//这里可以做赋值操作\n\t\t\twindow.clearInterval(winTimer);\n\t\t\tif (callback) &#123;\n\t\t\t\t//从callback(val)中获取返回值\n\t\t\t\tcallback(window.returnValue)\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;, 500);\n&#125;\n子页面 子窗体通过window.opener.window.returnValue&#x3D;””来传值\n","slug":"window-showModalDialog的替代方案","date":"2023-02-15T07:51:00.000Z","categories_index":"前端,Javascript","tags_index":"Javascript,浏览器兼容,老系统改造,原创","author_index":"Abner"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new \"My New Post\"\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2023-02-14T07:34:49.275Z","categories_index":"","tags_index":"","author_index":"Abner"},{"id":"7ffc1ad5305b44576f321dc2b2648ac9","title":"闭包及其适用场景（防抖、节流）","content":"闭包\n\n\n\n\n\n\n\n\n闭包是指函数可以访问并操作其词法作用域之外的变量。它通过在函数内部创建一个内部函数，并返回该内部函数来实现。\nfunction outer() &#123;\n  let x = 10;\n  function inner() &#123;\n    console.log(x);\n  &#125;\n  return inner;\n&#125;\n\nlet closure = outer();\nclosure(); // 输出 10\n\n闭包的适用场景场景一： 典型应用是模块封装，在各模块规范出现之前，都是用这样的方式防止变量污染全局。场景二： 在循环中创建闭包，防止取到意外的值。场景三：函数防抖 ，函数节流防抖适用场景\n\n按钮提交场景：防止多次提交按钮，只执行最后提交的一次\n\n搜索框联想场景：防止联想发送请求，只发送最后一次输入\n\n\n节流适用场景\n\n轮播图\n\n拖拽场景：固定时间内只执行一次，防止超高频次触发位置变动\n\n缩放场景：监控浏览器resize\n\n\n\n\n\n\n\n\n\n\n\n防抖是只在最后一次事件触发后才会执行一次函数。节流不管事件触发多频繁保证在一定时间内一定会执行一次函数。\n防抖和节流都是为了阻止操作高频触发，从而浪费性能。\n防抖\n\n\n\n\n\n\n\n\n只在最后一次事件触发后才会执行一次函数\n实现思路\n定义一个计时器变量，默认为null。\n当事件触发时，清除之前的计时器。\n创建一个新的计时器，延迟执行目标函数。\n在在此时间内，如果再次触了事件，则重复步骤2和3。\n在延迟时间内没有再次触发事件时，执行目标函数。\n\n// 首次不执行\nfunction debounce(fn,delay=200)&#123;\n        let timer = null;\n        return function()&#123;\n                if(timer) clearTimeout(timer);\n                timer = setTimeout(()=>&#123;\n                        fn.apply(this,arguments);\n                        timer = null;\n                &#125;,delay);\n        &#125;\n&#125;\n// 首次执行\nfunction debounce2(fn, delay = 200, atBegin = true) &#123;\n        let timer = null, last = 0,during;\n        return function () &#123;\n                let self = this, args = arguments;\n                var exec = function () &#123;\n                        fn.apply(self, args);\n                &#125;\n                if (atBegin &amp;&amp; !timer) &#123;\n                        exec();\n                        atBegin = false;\n                &#125; else &#123;\n                        during = Date.now() - last;\n                        if (during > delay) &#123;\n                                exec();\n                        &#125; else &#123;\n                                if (timer) clearTimeout(timer);\n                                timer = setTimeout(function () &#123;\n                                        exec();\n                                &#125;, delay);\n                        &#125;\n                &#125;\n                last = Date.now();\n        &#125;\n&#125;\n\n节流实现思路\n定义一个标记变量来表示是否允许执行目标函数，默认为0。\n当事件触发时，检查当前的时间戳与标记变量的差值，如果差值大于设定的延迟时间，则执行函数并将标记变量设为当前的时间戳。如果差值小于设定的延迟时间，则不执行。\n在指定时间间隔内再次触发事件时，则重复2步骤。\n\n// 首次不执行\nfunction throttle(fn,delay=100)&#123;\n        //首先设定一个变量，在没有执行我们的定时器时为null\n        let timer = null;\n        return function()&#123;\n                //当我们发现这个定时器存在时，则表示定时器已经在运行中，需要返回\n                if(timer) return;\n                timer = setTimeout(()=>&#123;\n                        fn.apply(this,arguments);\n                        timer = null;\n                &#125;,delay);\n        &#125;\n&#125;\n// 首次执行\nfunction throttle2(fn,delay=100)&#123;\n        let last = 0;\n        return function()&#123;\n                let curr = +new Date();\n                if(curr - last > delay)&#123;\n                        fn.apply(this,arguments);\n                        last = curr;\n                &#125;\n        &#125;\n&#125;\n","slug":"闭包及其适用场景（防抖、节流）","date":"2022-03-07T06:35:07.000Z","categories_index":"js","tags_index":"js","author_index":"Abner"}]